{"metadata": {"kernelspec": {"display_name": "R", "name": "ir", "language": "R"}, "language_info": {"name": "R", "file_extension": ".r", "version": "3.4.1", "mimetype": "text/x-r-source", "codemirror_mode": "r", "pygments_lexer": "r"}}, "cells": [{"source": ["September 14, 2017\n", "\n", "Meagan Gentry\n", "\n", "## Table of Contents\n", "1. Objective\n", "2. Data Partitioning\n", "3. Categorical Feature Transformations\n", "    * Cabin_Deck\n", "    * Ticket_Digit & Ticket_Alpha\n", "    * Family_Size\n", "    * Name_Family\n", "    * Title\n", "4. Missing Values\n", "    * Missingness\n", "    * Imputation\n", "5. Correlations\n", "6. Exploration\n", "    * Can we determine survival from the passenger's deck?\n", "    * Do families tend to survive together?\n", "    * Does being a male with a professional title (Doctors, Reverends, etc) help a passenger's chance of survival?"], "metadata": {"_uuid": "05ce28adc7a4ccad0c6c4e05dd945e9e37767861", "_cell_guid": "b0cd080d-3175-4e08-b982-466ef4aa8d79"}, "cell_type": "markdown"}, {"source": ["## Objective\n", "Let's use R to explore the Titanic data set and engineer some meaningful features to try in a classification model for passenger survival. Since there are missing values for some observations, we can impute them or choose to exclude them entirely from our modeling."], "metadata": {"_uuid": "91eea27e76869a256d86117df1ed9e367ce5d318", "_cell_guid": "efcdd551-4cf1-454e-bedb-7bade4b1d561"}, "cell_type": "markdown"}, {"source": ["#load packages\n", "library(\"ggplot2\") # data visualization\n", "library(\"caret\") # multiple model training/testing functions\n", "library(\"readr\") # CSV file I/O, e.g. the read_csv function\n", "library(\"dplyr\") # several Hadley Wickham data-wrangling packages\n", "library(\"mice\") # imputing missing values\n", "library(\"VIM\") # visualizing missing values\n", "library(\"stringr\") # feature engineering\n", "library(\"arules\") # feature engineering\n", "library(\"corrplot\") # correlogram \n", "\n", "options(warn=-1) # turn warnings off "], "outputs": [], "execution_count": null, "metadata": {"_uuid": "448f6100f73fd712348d37ea56368eead908e913", "_cell_guid": "9546dda9-bfc4-4d10-8fa0-580424ac78ce"}, "cell_type": "code"}, {"source": ["## Data Partitioning\n", "All methods used for transforming or imputing variable values should be performed the same way for training, validation, and testing data sets. First, we will partition the randomized training set into two sets (training 80% and validation 20%). Then, we can do our exploration on the training set, and streamline the process for validation and testing.\n"], "metadata": {"_uuid": "bc81b76dd853a508d170fc159aa3394ef156da84", "_cell_guid": "5ae0e476-1c45-4bce-a4a9-077996987bb1"}, "cell_type": "markdown"}, {"source": ["# read in the data\n", "train_full <- read_csv('../input/train.csv')\n", "\n", "# train split into train and validate\n", "inTrain <- createDataPartition(train_full$Survived, times = 1, p = 0.8, list=F)\n", "\n", "train <- train_full[inTrain,]\n", "val <- train_full[-inTrain,]"], "outputs": [], "execution_count": null, "metadata": {"_uuid": "1dfa5e4f0e4ecae1dce1af53a5d2ea1ef10abdb8", "_cell_guid": "cdfff337-6c8e-4884-b440-c5aa893ab6b4"}, "cell_type": "code"}, {"source": ["nrow(train) # number of training observations\n", "nrow(val) # number of training observations"], "outputs": [], "execution_count": null, "metadata": {"_uuid": "485dcced97e953503448336f0091c170bb36fe12", "_cell_guid": "c904aab4-863b-44c4-9cec-3f00fe12db5c"}, "cell_type": "code"}, {"source": ["## Categorical Feature Transformations\n", "Some categorical variables are hard to interpret or have too many levels to use intelligently in a classification model. For example, the Cabin for a passenger might give indication of where the passenger was at the time of the sinking of the ship: upper or lower deck; front or back of the ship. However, we cannot easily decode that information from the levels in the Cabin variable as-is. With a combination of research and transformation, we can make new variables that could mean a smarter model. Let's do some feature engineering!\n", "\n", "### Cabin_Deck \n", "If the layout of the Titanic is such that the Boat Deck is the top deck, followed by A, and so on until the G deck then \n", "we could transform Cabin to a more usable variable, Cabin_Deck.\n", "\n", "source: https://www.encyclopedia-titanica.org/titanic-deckplans/profile.html \n", "### Ticket_Digit & Ticket_Alpha\n", "Each Ticket value is an identification string of alphanumeric characters, mostly numeric. The value itself does not appear to indicate much detail about the passenger, but I hypothesize that the number of digits (Ticket_Digit) and whether or not the Ticket ID contains an alphabetic character (Ticket_Alpha) may have something to do with when the ticket was purchased.\n", "### Family_Size\n", "Each passenger has a Parch (Parent/Children) count and a SibSp (Sibling/Spouse) count. The sum of all family members might be useful.\n", "### Name_Family\n", "Since we know that some passengers are on board with their family members, we might assume that some of these families would share last names, given in the first few characters of the Name variable. We could hypothesize that families would take extra care in assuring that their other family members survive the shipwreck.\n", "### Title\n", "The Title of the passenger can be found in the Name variable. We could hypothesize that some titles will indicate status, which may be linked to survival."], "metadata": {"_uuid": "a2f12a135b794f3933f58edb8978d7731b9f69a6", "_cell_guid": "3d26c6f7-6cb4-4de7-8b2d-bd7fd32b2a5b"}, "cell_type": "markdown"}, {"source": ["train <- mutate(train,\n", "                Cabin_Deck = str_sub(Cabin,1,1),\n", "                Ticket_Digit = nchar(Ticket),\n", "                Ticket_Alpha = str_detect(Ticket, '[[:alpha:]]'),\n", "                Family_Size = Parch+SibSp,\n", "                Name_Family = gsub(\",.*$\", \"\", Name),\n", "                Title = str_sub(Name, \n", "                                str_locate(Name, \",\")[ , 1] + 2, \n", "                                str_locate(Name, \"\\\\.\")[ , 1] - 1)\n", "               )\n", "# credit to https://www.kaggle.com/c/titanic/discussion/30733 for Title regex"], "outputs": [], "execution_count": null, "metadata": {"_uuid": "9a3ad868cc50f329cbd730799164cc21c31bd182", "_cell_guid": "9d8ea349-1a24-4eb0-8d1a-9b6ab277a642"}, "cell_type": "code"}, {"source": ["## Missing Values\n", "Some observations have missing values. If left missing, these observations cannot be used to train our survival classification model. Plus, if we can't figure out a way to systematically 'impute' (or fill in) the missing values in our train set, then we cannot impute values in the test set either, which may be a problem if we need those values to classify survival.\n", "\n", "If we intend to impute variables, we should be able to assume that the missing values are missing at random. If the missing value are not missing at random, we could still impute them, but we should be wary that the imputed values may be highly correlated with other variables. The reasoning behind this is summarized well here (http://www.theanalysisfactor.com/missing-data-mechanism/). \n", "\n", "Next, we can\n", "1. visualize missing values in the training data, \n", "2. determine the pattern of missingness (missingness mechanism) if we can, and \n", "3. figure out a way to impute missing values if they are frequent."], "metadata": {"_uuid": "88239a456c8430af7671d6fda22263471458efd9", "_cell_guid": "a56b8112-bdb6-4f4c-bb37-32db6c6b1455"}, "cell_type": "markdown"}, {"source": ["# subset training data to include only variables we would consider using in our model\n", "train_sub <- select(train,\n", "                    Survived,Pclass,Sex,Age,SibSp,Parch,Fare,Embarked,\n", "                    Cabin_Deck,Ticket_Digit,Ticket_Alpha,Name_Family,Title,Family_Size)\n", "# missing value pattern matrix\n", "md.pattern(train_sub)\n", "\n", "# visualization of missing values\n", "train_mice_plot <- aggr(train_sub, col=c('palegreen2','palegoldenrod'),\n", "                    numbers=T, sortVars=T,\n", "                    labels=names(train_sub), cex.axis=.7,\n", "                    gap=3, ylab=c(\"Missing data\",\"Pattern\"))"], "outputs": [], "execution_count": null, "metadata": {"_uuid": "315fc7683db2d28057887b32f1f908097557e616", "_cell_guid": "d20fe4a7-7ad4-46d2-a410-e07048613c36"}, "cell_type": "code"}, {"source": ["Age and Cabin are the two variables with the highest frequency of missing values in our training set. One way to test whether or not these are MAR or NMAR (missing at random or not missing at random, respectively) is to look at the distribution of complete variables for observations where Age or Cabin is missing and present. Below are some metrics for these distributions that demonstrate a loose test of the hypothesis:\n", "\n", "> The missing values (for Age or Cabin) are correlated with at least one other variable that has no missing values (aka not  missing at random)."], "metadata": {}, "cell_type": "markdown"}, {"source": ["# Hypothesis: Age missing values are correlated with at least one other variable that has no missing values (aka not totally missing at random)\n", "print('Proportion Table: TRUE = Age is missing  X  Survived = 1 if survived')\n", "round(prop.table(table(is.na(train$Age), train$Survived), 1),2)\n", "\n", "print('Proportion Table: TRUE = Age is missing  X  Pclass = 1 is first class')\n", "round(prop.table(table(is.na(train$Age), train$Pclass), 1),2)\n", "\n", "print('Distribution of Fare  X  Age missing vs present')\n", "print('Age missing')\n", "summary(train %>% \n", "        filter(is.na(Age)) %>%\n", "        select(Fare)\n", "        )\n", "print('Age present')\n", "summary(train %>% \n", "        filter(!is.na(Age)) %>%\n", "        select(Fare)\n", "        )"], "outputs": [], "execution_count": null, "metadata": {"_kg_hide-input": false}, "cell_type": "code"}, {"source": ["The missingness mechanism for Age **may** favor:\n", "1. Passengers who did not Survive\n", "2. Passengers who are in lower (2nd or 3rd class)\n", "3. Passengers who have paid, on average, around $13 less for their Fare ($34.71 - $21.31)"], "metadata": {}, "cell_type": "markdown"}, {"source": ["# Hypothesis: Cabin missing values are correlated with at least one other variable that has no missing values (aka not totally missing at random)\n", "\n", "print('Proportion Table: TRUE = Cabin/Deck is missing  X  Survived = 1 if survived')\n", "round(prop.table(table(is.na(train$Cabin_Deck), train$Survived), 1),2)\n", "\n", "print('Proportion Table: TRUE = Cabin/Deck is missing  X  Pclass = 1 is first class')\n", "round(prop.table(table(is.na(train$Cabin_Deck), train$Pclass), 1),2)\n", "\n", "print('Distribution of Fare  X  Cabin/Deck missing vs present')\n", "print('Cabin/Deck missing')\n", "summary(train %>% \n", "        filter(is.na(Cabin_Deck)) %>%\n", "        select(Fare)\n", "        )\n", "print('Cabin/Deck present')\n", "summary(train %>% \n", "        filter(!is.na(Cabin_Deck)) %>%\n", "        select(Fare)\n", "        )"], "outputs": [], "execution_count": null, "metadata": {}, "cell_type": "code"}, {"source": ["The missingness mechanism for Cabin/Deck **absolutely** favor:\n", "1. Passengers who did not Survive (inverse correlation between missing and not missing)\n", "2. Passengers who are in lower class (inverse correlation between missing and not missing)\n", "3. Passengers who have paid, on average, around $54 less for their Fare ($76.54 - $18.95)"], "metadata": {}, "cell_type": "markdown"}, {"source": ["### Imputation\n", "The mice package allows us to impute continuous variables easily. Since our complete variables are a combination of categorical and continuous, we can impute the missing values for Age by modeling regression trees with the complete variables as input ('cart' option)."], "metadata": {"_uuid": "d25f60c3e8ba1191e67898ef9f91781b0b8d60ab", "_cell_guid": "df24db4e-c9e1-422a-82ad-3ff1cdc40572"}, "cell_type": "markdown"}, {"source": ["train_mm <- model.matrix(~Pclass+Sex+Age+\n", "                         SibSp+Parch+Fare+\n", "                         Embarked+Cabin_Deck+\n", "                         Ticket_Digit+Ticket_Alpha+Title+Name_Family,\n", "                         train_sub)\n", "\n", "train_imp <- mice(train_sub, \n", "                  m = 1,\n", "                  method = \"cart\", \n", "                  seed = 5, \n", "                  printFlag=FALSE)\n", "\n", "# check out the distribution of imputed Age values\n", "# imputed values look like they match the general distribution of the complete values\n", "summary(train_imp$imp$Age) \n", "\n", "# merge imputed values with complete observations\n", "train <- complete(train_imp) \n", "\n", "Age_hist_imp <- ggplot(train, aes(Age))\n", "Age_hist_imp + geom_histogram(binwidth = 5) \n", "\n", "# check to see if any NAs in Age after imputation: none\n", "which(is.na(train$Age)==T) "], "outputs": [], "execution_count": null, "metadata": {"_uuid": "db83715ebd9952b4f3db6309e90adb36c0021615", "_cell_guid": "0b4e4c8b-83e1-4b2f-a75e-861b9ec6a0f0"}, "cell_type": "code"}, {"source": ["### Cabin_Deck\n", "Cabin/Deck is missing (NA) for many subjects (77% of the train set), but we may still want to use these subjects to train our classification model. We could impute these values if we assumed they are correlated with some other variables.\n", "\n", "From a previous Kaggle discussion (https://www.kaggle.com/c/titanic/discussion/3189), one Kaggler says that his research led him to find that: \n", "> Cabins A-D were assigned for the 1st class, \n", "> E for the 2nd and F for the 3rd. \n", "> Cabin T was also a first class cabin.\n", "\n", "Pclass has no missing values, so this might be a good variable to use for Cabin_Deck imputation. Below, we have demonstrated how to impute missing Cabin_Deck using Pclass."], "metadata": {"_uuid": "b6075bd8d911b8e7c46c6aa3abdb7beca1bfe229", "_cell_guid": "b51a246e-f143-440d-a163-254451228619"}, "cell_type": "markdown"}, {"source": ["train <- mutate(train, \n", "                Cabin_Deck_i = ifelse(!is.na(Cabin_Deck),\n", "                                Cabin_Deck,\n", "                                ifelse(Pclass == 1,\n", "                                       'ABCD', \n", "                                        # not including T because only one passenger\n", "                                        # in the training set was assigned cabin T\n", "                                       ifelse(Pclass == 2,\n", "                                              'E',\n", "                                             'F'))))"], "outputs": [], "execution_count": null, "metadata": {"_uuid": "5d49a74500f87c2ac8ce45d0378d90581539729c", "_cell_guid": "43355998-4197-4217-98ef-cc15d0b11764"}, "cell_type": "code"}, {"source": ["Is there a way to more specifically impute the values that we have determined are Cabin_Deck_i = ABCD? We could hypothesize that higher decks (A-level) might cost more with respect to Fare (which is available for all first class or Pclass = 1 passengers). We could break apart the ABCD level by discretizing Fare for first class passengers."], "metadata": {"_uuid": "49357ec6656aa527fad07be3b5dc286d3a4e5530", "_cell_guid": "769a69bd-3b6e-4920-8cce-a83baabbd0e2"}, "cell_type": "markdown"}, {"source": ["# histogram of Fare by Pclass (no missing values)\n", "Fare_hist <- ggplot(train, aes(Fare))\n", "Fare_hist + geom_histogram(binwidth=25) + facet_grid(Pclass~.)\n", "\n", "# subset passengers to consider first class only\n", "train_Pclass1 <- filter(train, Pclass == 1) \n", "\n", "# divide the Fare distribution for Pclass 1 into \n", "# the number of Decks (4) that we need to break apart\n", "# for Cabin_Deck imputation\n", "cuts <- discretize(train_Pclass1$Fare,\n", "                   method = 'cluster',\n", "                   categories = 4,\n", "                   ordered = T,\n", "                   onlycuts = T)\n", "\n", "train <- mutate(train, Cabin_Deck_i2 = ifelse(Cabin_Deck_i != \"ABCD\",\n", "                                       Cabin_Deck_i,\n", "                                       ifelse(Fare < cuts[2],\n", "                                             \"D\",\n", "                                             ifelse(Fare < cuts[3],\n", "                                                   \"C\",\n", "                                                   ifelse(Fare < cuts[4],\n", "                                                         \"B\", \n", "                                                         \"A\")))))"], "outputs": [], "execution_count": null, "metadata": {"_uuid": "48a43cf68c341a47248f972e4ff14b8ee3e52de9", "_cell_guid": "07319f97-4212-44a5-b55d-b84031de741f"}, "cell_type": "code"}, {"source": ["If we were interested in looking at Cabin_Deck as a ordinal variable, we could enumerate it. Below we demonstrate how to transform Cabin_Deck such that A is the 1st deck and T is the last."], "metadata": {"_uuid": "4baca0dfdab19c6b361bada7131786d2918e90c8", "_cell_guid": "0c79db26-c4ba-4f61-9e89-633ceb92c3bd"}, "cell_type": "markdown"}, {"source": ["train <- mutate(train, Cabin_Deck_i3 = ifelse(Cabin_Deck_i2 == 'A',1,\n", "                                ifelse(Cabin_Deck_i2 == 'B',2,\n", "                                      ifelse(Cabin_Deck_i2 == 'C',3,\n", "                                            ifelse(Cabin_Deck_i2 == 'D',4,\n", "                                                  ifelse(Cabin_Deck_i2 == 'E',5,\n", "                                                        ifelse(Cabin_Deck_i2 == 'F',6,\n", "                                                              ifelse(Cabin_Deck_i2 == 'G',7,8))))))))"], "outputs": [], "execution_count": null, "metadata": {"_uuid": "6ecc6f2142fa944fe2d7dd80c07e79999aabbc45", "_cell_guid": "d9b80f32-6a6a-4a75-997b-c0358680a755"}, "cell_type": "code"}, {"source": ["### Embarked\n", "Embarked has potential missing values in the train and validation sets, but not very many. Since the distribution of Embarked values is majority 'S' for Southampton, we can probably safely use 'modal imputation'. Below, we impute Emabrked missing values by assigning them the 'S', or mode, value."], "metadata": {"_uuid": "7f98007e87f005baf85322c377068f794566022e", "_cell_guid": "17105369-d014-4443-863e-bb9c219f6452"}, "cell_type": "markdown"}, {"source": ["train <- mutate(train, \n", "                Embarked = ifelse(is.na(Embarked),\n", "                                 'S', Embarked))"], "outputs": [], "execution_count": null, "metadata": {"_uuid": "fcc0e06f0b2cc0ed77947bcde9d101dfd0285ccf", "_cell_guid": "5a29ce7c-cf97-4ed3-9b65-88f08c4b7754"}, "cell_type": "code"}, {"source": ["## Correlations\n", "Before we train any classifiers on the variables we have created for the training set, we should understand any correlations between any two variables and determine whether or not both or just one of these variables should be represented in the final model. \n", "\n", "We can ignore the strong correlation between Parch, SibSp, and Family_Size since we created Family_Size from them. "], "metadata": {"_uuid": "c8f2670dc6978732f4c9a9399c454f3120aea57f", "_cell_guid": "14bb58b1-8e66-4c53-805e-18bdd7fb6818"}, "cell_type": "markdown"}, {"source": ["train_cor <- select(train,\n", "                    Age, Fare, SibSp, Parch,\n", "                    Pclass, Cabin_Deck_i3,\n", "                    Ticket_Digit,\n", "                    Family_Size)\n", "cor <- cor(train_cor)\n", "corrplot(cor, method=\"number\")"], "outputs": [], "execution_count": null, "metadata": {"_uuid": "d8946fbd984e55bb1419b804f8a016c059b89669", "_cell_guid": "e6bdb1e8-b67d-4758-9d14-b7ee467f6e83"}, "cell_type": "code"}, {"source": ["The only correlations with a magnitude > 0.5 are between \n", "\n", "**Pclass and Fare**\n", "\n", "Although the relationship is not strong enough to combine the variables or choose only one to use, it is an expected relationship: if the passenger's Fare is high, the class is likely to be 'upper' or 1st.\n", "\n", "**Cabin_Deck_i3 and Fare**\n", "\n", "This relationship could be explained by our use of Fare to impute a large percentage of Cabin_Deck missing values."], "metadata": {"_uuid": "81b8ba2f363386858c046ce4f26a4e456d31ebfd", "_cell_guid": "f6d2e90a-62c1-457e-8f26-a8910f2041cc"}, "cell_type": "markdown"}, {"source": ["## Exploration\n", "### Can we determine survival from the passenger's deck?"], "metadata": {"_uuid": "2b5db59df6583ed080d2dd381f07f17e17db8150", "_cell_guid": "71f08154-2d2b-47c0-a087-431214016615"}, "cell_type": "markdown"}, {"source": ["Deck_plot <- ggplot(train, aes(Cabin_Deck_i2))\n", "Deck_plot + geom_bar(aes(fill = as.factor(Survived)))\n", "\n", "round(prop.table(table(train$Cabin_Deck_i2, train$Survived), 1),2)"], "outputs": [], "execution_count": null, "metadata": {}, "cell_type": "code"}, {"source": ["### Do families tend to survive together?"], "metadata": {}, "cell_type": "markdown"}, {"source": ["Family_plot <- ggplot(train, aes(Family_Size))\n", "Family_plot + geom_histogram(aes(fill = as.factor(Survived)))"], "outputs": [], "execution_count": null, "metadata": {}, "cell_type": "code"}, {"source": ["### Does being a male with a professional title (Doctors, Reverends, etc) help a passenger's chance of survival?"], "metadata": {}, "cell_type": "markdown"}, {"source": ["Title_plot <- ggplot(train, aes(Title))\n", "Title_plot + geom_bar(aes(fill = as.factor(Survived)))\n", "\n", "round(prop.table(table(train$Title, train$Survived), 1),2)"], "outputs": [], "execution_count": null, "metadata": {"_uuid": "9a1ca22d0e2c2323dd979e9ce70a5279d4486a52", "_cell_guid": "d119296e-2dd4-4e31-a05f-3866be99f17f"}, "cell_type": "code"}, {"source": ["*Thanks! And stay tuned for my Titanic model training and submission!*"], "metadata": {}, "cell_type": "markdown"}], "nbformat_minor": 1, "nbformat": 4}