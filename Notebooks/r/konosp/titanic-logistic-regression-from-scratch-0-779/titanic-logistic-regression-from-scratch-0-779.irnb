{"nbformat_minor": 1, "cells": [{"metadata": {"_cell_guid": "cdd899f4-8ef5-41b6-bfe5-2bbfa3e84f09", "_uuid": "0c2ddfe2627a65c6a173b362b4b51888c74ad273"}, "source": ["The following Titanic kernel is based on the logistic regression theory that is part of the course Machine Learning on Coursera by Andrew Ng."], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "e6a0aaa0-cfae-4b4d-a3f5-c9e0b1be1558", "_uuid": "336b937e3f6dab29d7ff6b4aa78eae195ba04356", "_kg_hide-input": true, "_kg_hide-output": true}, "source": ["# This R environment comes with all of CRAN preinstalled, as well as many other helpful packages\n", "# The environment is defined by the kaggle/rstats docker image: https://github.com/kaggle/docker-rstats\n", "# For example, here's several helpful packages to load in \n", "\n", "library(ggplot2) # Data visualization\n", "library(readr) # CSV file I/O, e.g. the read_csv function\n", "\n", "# Input data files are available in the \"../input/\" directory.\n", "# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory\n", "\n", "system(\"ls ../input\")\n", "\n", "test_data <- read_csv(\"../input/test.csv\")\n", "train_data <- read_csv(\"../input/train.csv\")\n", "\n", "library(ggplot2)\n", "library(dplyr)\n", "library(tidyr)\n", "library(readr)\n", "\n", "# Any results you write to the current directory are saved as output."], "cell_type": "code"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "fca0fec2-2b0d-4fa9-8092-1fb5200ce3ba", "_uuid": "aadc9fdc7c88bed7b941ff3b0c652a0c4a0c8738", "_kg_hide-input": false, "_kg_hide-output": true}, "source": ["# Generic function to format both training and test set\n", "format.tables <- function(df){\n", "  \n", "  #df$Survived <- as.factor(df$Survived)\n", "  df$Pclass <- as.factor(df$Pclass)\n", "  df$Sex <- as.factor(df$Sex)\n", "  df$Embarked <- as.factor(df$Embarked)\n", "  \n", "  # Dummy variable for Sex\n", "  df$Sex.int <- 0\n", "  df[df$Sex == 'male',]$Sex.int <- 1\n", "  \n", "  # Dummy variable for Pclass\n", "  #df$Pclass <- as.integer(df$Pclass)\n", "  tmp <- model.matrix(PassengerId ~ Pclass,df[,c('PassengerId','Pclass')])\n", "  df <- cbind(df,tmp[,-1])\n", "  \n", "  # Dummy variable if passenger has cabin\n", "  df$has_cabin <- 0\n", "  df[!is.na(df$Cabin),]$has_cabin <- 1\n", "  \n", "  tmp <- model.matrix(PassengerId ~ Embarked,df[,c('PassengerId','Embarked')])\n", "  df <- cbind(df,tmp[,-1])\n", "  \n", "  #df$embarked.C <- 0\n", "  #df$embarked.Q <- 0\n", "  #df[df$Embarked == 'C',]$embarked.C <- 1\n", "  #df[df$Embarked == 'Q',]$embarked.Q <- 1\n", "  \n", "  df$age_missing <- 0\n", "  df[is.na(df$Age),]$age_missing <- 1\n", "  \n", "  # Titles\n", "  titles <- df %>% select('Name') %>% \n", "    separate(col = Name,into = c('A','B'), sep = ',') %>% \n", "    separate(col = B,into = c('A2','B2'), sep = '. ') %>% \n", "    select('A2')\n", "  \n", "  df$title <-trimws(titles$A2)\n", "  # df$title <- as.factor(df$title)\n", "  tmp <- table(df$title) < 15\n", "  df[tmp[df$title] == TRUE,]$title <- 'Other'\n", "  \n", "  tmp <- model.matrix(Name ~ title,df[,c('title','Name')])\n", "  df <- cbind(df,tmp[,-1])\n", "  \n", "  return(df)\n", "}"], "cell_type": "code"}, {"metadata": {"_cell_guid": "2e5894be-4161-44b3-8e4b-73e1c41ac730", "_uuid": "65d4e6e650d04ac87d04062ef55f4f63e1e1991c"}, "source": ["The following basic functions are defined:\n", "1. Sigmoid function (https://en.wikipedia.org/wiki/Sigmoid_function)\n", "2. Logistic regression cost function. Based on the cost function we fit the optimum parameters for the model"], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "d551946c-dd85-412b-afa0-36ecf0194be3", "_uuid": "fa46e6cbe9ebfa0ebf34b6d801be84bfcbb961a9", "_kg_hide-input": false, "_kg_hide-output": true}, "source": ["# Sigmoid function\n", "G <- function(z) {\n", "  return(1 / (1 + exp(-z)))\n", "}\n", "\n", "# Defaut definition of Z\n", "# Not used in the actual code\n", "# Z <- t(theta) %*% X\n", "\n", "# Cost function\n", "J <- function(theta, X, y){\n", "  z <- X %*% theta\n", "  sigmoid <- G(z)\n", "  m <- length(y)\n", "  res <- (-t(y) %*% log(sigmoid) - (t(1 - y) %*% log(1 - sigmoid)))/m\n", "  return(res)\n", "}\n", "\n", "# Hypothesis function sample\n", "# Not used in the actual code\n", "# H <- G(Z)\n"], "cell_type": "code"}, {"metadata": {"_cell_guid": "8cac4d20-ae1d-4012-a6cc-0c6dc89e7ba9", "_uuid": "b5d36460b82626c72abbe37bad4eceabcda58b15"}, "source": ["From reviewing the initial train data, we identify that the embarked port is missing from a couple of passengers."], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "c5e65649-5ab4-462f-b4e6-6cb1893c4264", "_uuid": "e03a7014f684a8d95af04a5920f5622136cea663", "_kg_hide-output": false}, "source": ["table(is.na(train_data$Embarked))"], "cell_type": "code"}, {"metadata": {"_cell_guid": "9c37d7f0-d4bb-4072-b822-dfe4c0eb8184", "_uuid": "cd8e278f43233a814c5005c6e48b198640fecfb2", "_kg_hide-output": true}, "source": ["In order to fill those values, we will use the fare payed by passengers for the different ports (this idea originates from a different kernel but it is very easy to use to fill in the missing values)."], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "3891b3d8-f55d-458c-ac3f-161e78e16de9", "_uuid": "ea14494cc811c9e089c89937ab579dc385f95d84", "_kg_hide-input": true}, "source": ["\n", "# Diclaimer: Idea was found on different kernel\n", "# Filling missing Embarked data\n", "p1 <- ggplot(train_data)\n", "p1 + aes(x = Embarked, y = Fare, color = as.factor(Pclass)) + \n", "  geom_boxplot() + \n", "  geom_hline(yintercept = median(train_data[is.na(train_data$Embarked),]$Fare), \n", "             linetype = 'dashed', color = 'blue')  + theme(legend.position=\"bottom\")"], "cell_type": "code"}, {"metadata": {"_cell_guid": "d957ffd8-c156-4efd-84b8-9126aa6df7d7", "_uuid": "6e38eaf3b866f71b431830d607342815b981bf00"}, "source": ["It looks like the media fare value for the passengers without a port is matching port C. Let's fill the missing values."], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "acc6d302-2b82-4eae-9286-3b2c885a2ce5", "_uuid": "6112c3957f8ab055cc9f34598a833acf2d56c47a", "_kg_hide-input": false, "_kg_hide-output": true}, "source": ["# Fill missing embarked lines based on median\n", "train_data[is.na(train_data$Embarked),]$Embarked <- 'C'"], "cell_type": "code"}, {"metadata": {"_cell_guid": "67c20f46-b6a0-46f7-b085-bc91b0a7a145", "_uuid": "83b9c3edbb8e6959302c7127237b03e0b087cc86"}, "source": ["**Now it is time for the exciting things! The following operations take place:**\n", "* Format the data into dummy 0/1 variables so we can then feed the columns into the sigmoid function"], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "6722d04c-28d0-4d14-abb1-61ae7904d3af", "_uuid": "e1f1f24e68900193b8821a2480b0888cb6dc598c", "_kg_hide-input": false, "_kg_hide-output": true}, "source": ["# Format coloumns to 0/1 dummy format\n", "test_data <- format.tables(test_data)\n", "train_data <- format.tables(train_data)"], "cell_type": "code"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "8233ba21-d56d-4798-b26c-5b131ed38d71", "_uuid": "515c64e2a5c2f987514d3be30d9a783df090b15d", "_kg_hide-input": true, "_kg_hide-output": false, "scrolled": true}, "source": ["coloumns.to.fit <- c('Pclass2','Pclass3','Sex.int',\n", "                     'SibSp','Parch',\n", "                     'has_cabin','age_missing',\n", "                     'EmbarkedQ','EmbarkedS', 'titleMiss', 'titleMr', 'titleMrs','titleOther')\n", "\n", "head(train_data[,coloumns.to.fit],10)"], "cell_type": "code"}, {"metadata": {"_cell_guid": "8108a02a-2214-4897-b151-bc077d8ccc4a", "_uuid": "0380af1a26b25d49598a307bc2bdd43a53e610a2"}, "source": ["* Initialize the parameters (theta.initial) so the algorithm can start fitting the values"], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "0a6d9a2a-57a5-4752-b13e-50171dcdb261", "_uuid": "294a400bc1442152d646fead6a4c174e653cd135", "_kg_hide-output": true}, "source": ["# Vector of zeros: [0,0,0, ... ,0] equal to the number of columns\n", "theta.initial <- as.vector(rep(0,length(coloumns.to.fit)))"], "cell_type": "code"}, {"metadata": {"_cell_guid": "d4ee99ff-670e-4d74-9a74-260acd7fedf2", "_uuid": "3e35c573105d4be30461cc8e271026e3c9a34aba"}, "source": ["* Use the built-in R function \"optim\" to find the parameters theta (theta.optimized) that minimize the J cost function of the logist regression. "], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "1d955de6-8cc3-4738-9ad7-7baeb87ff4b9", "_uuid": "da9987a5bd7aa9bb181c227c35d47d3444e428d3", "_kg_hide-output": true}, "source": ["# Select the coloums that will be used\n", "X <- as.matrix(train_data[,coloumns.to.fit])\n", "y <- train_data$Survived\n", "# Find parameters theta that optimize (minimize) the cost function J.\n", "# The cost function measures the difference between predicted and actual class\n", "theta.optimized <- optim(theta.initial ,\n", "                         fn = J, \n", "                         X = X, \n", "                         y = y,\n", "                         control = list(maxit = 1000000))$par"], "cell_type": "code"}, {"metadata": {"_cell_guid": "8c6af0d9-3777-40d5-9a75-d119f1c51206", "_uuid": "d9e162cffd5f98192fd894ec3a85062f8ac6a1fd"}, "source": ["* Evaluate the result of the sigmoid function (probability of survival) for the complete training set using the optimized parameters theta."], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "03e5a07a-ea16-4f9e-a69b-e4b34b8ea1f5", "_uuid": "2539969bf41016a74e3eed0e6c8bc6817327202b", "_kg_hide-output": true}, "source": ["# Based on the optimized theta, generate the output values of the sigmoid function\n", "sigmoid.result <- G(X %*% theta.optimized)"], "cell_type": "code"}, {"metadata": {"_cell_guid": "c55361ad-9fac-4317-86da-26b891cfee59", "_uuid": "340b9218a7e084573013d75dc2c2de4557b3e828"}, "source": ["* The logistic regression requires to set the threshold based on which a passenger is classified as Survivor or not (it is not 50-50!). In order to do this, we use the training set to find the sweet spot (unfortunately I have not implemented cross-validation here)."], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "e22b873f-098f-4eca-bd48-b8525b068789", "_uuid": "59786e7da5badda08fee5ab01e458bdf1eb78cd9", "_kg_hide-output": true}, "source": ["# The logistic regretion requires to define the threshold that splits the two classes.\n", "# The threshold is a value in the set (0,1) - not inclusive\n", "# Find the thershold that maximises F1\n", "F1.max = 0\n", "F1 = 0\n", "threshold <- 0\n", "for(i in seq(from=0.01, to=1, by=0.005)){\n", "  # For each possible value of the threhold\n", "  # update predictions and evaluate F1\n", "  y_predict <- sigmoid.result > i\n", "  y_predict[y_predict == T] <- 1\n", "  y_predict[y_predict == F] <- 0\n", "  # Performance\n", "  results.table <- table(y_predict, train_data$Survived)\n", "  if (sum(dim(results.table)) == 4) {\n", "    precision <- results.table[2,2] / (results.table[2,2] + results.table[2,1])\n", "    recal <- results.table[2,2] / (results.table[2,2] + results.table[1,2])\n", "    F1 <- 2 * precision * recal / (precision + recal)   \n", "    # print(paste('Threshold: ', threshold, ' - ', 'F1: ', F1))\n", "    if (F1 >= F1.max){\n", "      F1.max <- F1\n", "      threshold <- i\n", "      # print(paste('Threshold: ', threshold, ' - ', 'F1: ', F1.max))\n", "    }\n", "  } \n", "}"], "cell_type": "code"}, {"metadata": {"_cell_guid": "4fa29b57-7c25-4b29-8079-bef6ab0daa3e", "_uuid": "a0f900514f899ca505107b906f0d7ff82c13194b"}, "source": ["**At this point, we have evaluated:**\n", "* Optimized theta parameters"], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "6a258506-e732-40f1-808b-9f8fa201d29d", "_uuid": "93aeeeaf01a7814f5726fc9c4c13577499712b0b", "_kg_hide-input": false, "_kg_hide-output": false, "scrolled": true}, "source": ["print(theta.optimized)"], "cell_type": "code"}, {"metadata": {"_cell_guid": "981394e6-f76c-4fb0-9bbc-a7ce43e56bd5", "_uuid": "c2241705a9b9f1f75c34888e89ea8a785bd17746"}, "source": ["* Comparison of actual versus predicted survival"], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "005da263-ed47-4086-bf70-a214e2e9f947", "_uuid": "601e5096776899beb4f291dbcfbf2176c446e917", "_kg_hide-input": false}, "source": ["# Final optimum prediction\n", "y_predict <- sigmoid.result > threshold\n", "y_predict[y_predict == T] <- 1\n", "y_predict[y_predict == F] <- 0\n", "\n", "# Performance on train set\n", "results.table <- table(y_predict, train_data$Survived,dnn = c('Predicted','Actual'))\n", "print(results.table)"], "cell_type": "code"}, {"metadata": {"_cell_guid": "9d32e63d-082f-4d2e-9d13-717528274898", "_uuid": "366daeaec314e43805311fa7d51345510fb463a7"}, "source": ["* Optimized classification threshold based on the F1-score (https://en.wikipedia.org/wiki/F1_score)"], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "08b4a06a-535a-43c9-86e5-65f85191395c", "_uuid": "a9effc5e205570a4a2158325250326b6c69e941c"}, "source": ["precision <- results.table[2,2] / (results.table[2,2] + results.table[2,1])\n", "recal <- results.table[2,2] / (results.table[2,2] + results.table[1,2])\n", "F1 <- 2 * precision * recal / (precision + recal)   \n", "print(paste('Threshold calculated: ', threshold, ' - ', 'F1-score: ', F1))"], "cell_type": "code"}, {"metadata": {"_cell_guid": "48e857e5-8024-4ddf-931f-d141d62eb7cc", "_uuid": "b4981fb1aba0e72bb6e78c8ac97837805af0f9fc"}, "source": ["**Time for some easy-to-digest algorithm performance depiction.** \n", "\n", "In the following graph we have:\n", "* The X-axis is the outcome of the sigmoid fuction (survival probability for each survivor)\n", "* The Y-axis is the number of passengers.\n", "* The vertical blue line represents the optimum threshold we have defined for this particular problem. All data points on the left of the line are predicted to have died. All data points on the right are predicted to have survived.\n", "* Data points in blue vs red represent the actual outcome on the training set.\n", "* The training set is split into male/female just becuase the differences are huge between those groups."], "cell_type": "markdown"}, {"execution_count": null, "outputs": [], "metadata": {"_cell_guid": "1c634791-77d1-4f7c-bea5-ab6d5bf2b5af", "_uuid": "abbb80f6ff1068bc5ab1a99e8de73393991fd151", "_kg_hide-input": false}, "source": ["\n", "# Visualization\n", "tmp <- cbind(as.data.frame(sigmoid.result), train_data$Survived,train_data$Sex)\n", "names(tmp) <- c('sigmoid','Actual Outcome','Sex')\n", "tmp$'Actual Outcome' <- as.character(tmp$'Actual Outcome')\n", "tmp[tmp$`Actual Outcome` == 1,]$`Actual Outcome` <- 'Survived'\n", "tmp[tmp$`Actual Outcome`== 0,]$`Actual Outcome` <- 'Died'\n", "tmp$`Actual Outcome` <- as.factor(tmp$`Actual Outcome`)\n", "p1 <- ggplot(tmp)\n", "p1 + aes(x = sigmoid, fill = `Actual Outcome`) + geom_histogram(bins = 75) + \n", "  ggtitle(paste('Threshold: ', threshold, ' - ', 'F1-score: ', round(F1.max,3) )) +\n", "  geom_vline(xintercept= threshold, color = 'blue') + facet_grid(Sex ~ .) +\n", "  geom_text(aes(x=threshold - 0.10, label=\"Predicted:Died\", y=100), colour=\"brown3\", angle=0) +\n", "  geom_text(aes(x=threshold + 0.15, label=\"Predicted:Survived\", y=100), colour=\"darkolivegreen4\", angle=0) +\n", "  geom_text(aes(x=threshold + 0.02, label=\"Threshold\", y = 65), colour=\"blue\", angle=90) +\n", "  xlab('Predicted probability of survival - Result of sigmoid function') +\n", "  ylab('Number of passengers') + theme(legend.position=\"bottom\")"], "cell_type": "code"}, {"metadata": {"_cell_guid": "e28ad1c4-7d16-46be-b1cb-0fe81cca52e3", "_uuid": "7a18986a2e0f36dcf6a645dfb81b195501471fc5"}, "source": ["It looks like the basic implementation of the logistic regression algorithm has delivered quite decent results without any complicated feature engineering and without fully utilizing variables like age, fare and ticket. Those are points for further investigation. However, even with this implementation, it achieves 0.77990 accuracy; not bad for a start.\n", "\n", "Please let me know of comments, ideas for improvements as well as any critical points missed in the process."], "cell_type": "markdown"}, {"metadata": {"_cell_guid": "9e28e0dd-37e3-4a9a-80d2-a1abf3b9f93c", "_uuid": "da2fff7f94b947192cc0d3662af3b3d334b88e19"}, "source": [], "cell_type": "markdown"}], "metadata": {"language_info": {"codemirror_mode": "r", "version": "3.4.2", "pygments_lexer": "r", "name": "R", "file_extension": ".r", "mimetype": "text/x-r-source"}, "kernelspec": {"language": "R", "display_name": "R", "name": "ir"}}, "nbformat": 4}