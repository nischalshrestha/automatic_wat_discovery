{"cells":[{"metadata":{"_uuid":"4d2b77cec1c9d025d4dd4423969c3f094e7ecc6e","_execution_state":"idle","trusted":false},"cell_type":"markdown","source":"# Loading the data \n\nData has been split in 2 for training purpose"},{"metadata":{"trusted":true,"_uuid":"ce174c4895ce7b49f3c03a8cbe05f192477f1126","_kg_hide-input":true},"cell_type":"code","source":"df <- read.csv('../input/train-data/train_data.csv', header=T,na.strings=c(''))\ndf_test <- read.csv('../input/data-test/test_data.csv', header=T,na.strings=c(''))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"452ffe0559e85472bf7c28f8864d94d8220a607f","scrolled":true},"cell_type":"code","source":"# Let Change the \"Pclass\" and \"Survived\" attributes to factors.\ndf$Pclass <- as.factor(df$Pclass)\ndf$Survived <- as.factor(df$Survived)\nstr(df) #to check the type of Pclass & Survived\n\ndf_test$Pclass <- as.factor(df_test$Pclass)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"0994c6b6951e86cf73c143f9b50072f4e8dfedd5"},"cell_type":"code","source":"# I will now check for missing values and look how many unique values there are for each variable \npaste('number of missing values for each variable')\nsapply(df,function(x) sum(is.na(x)))\nsapply(df_test,function(x) sum(is.na(x)))\n       \npaste('number of unique values for each variable')\nsapply(df, function(x) length(unique(x)))\nsapply(df_test, function(x) length(unique(x)))","execution_count":null,"outputs":[]},{"metadata":{"_kg_hide-input":false,"_kg_hide-output":false,"trusted":true,"_uuid":"b94aad9f69c6b7b0acb42721eaf3c1d25a69c2ea"},"cell_type":"code","source":"library(Amelia) # let plot our dataset and highlight missing values\npar(mfrow = c(2,1))\nmissmap(df, col = c('yellow','darkgreen'), main = 'Missing values vs observed')\nmissmap(df_test, col = c('yellow','darkgreen'), main = 'Missing values vs observed')","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"cd7dd26919c343856dd035b95e93bfb867a76203"},"cell_type":"markdown","source":"Dealing with the missing valuesÂ¶\n\nAs we can see on the plot above 3 variables have missing values.\n\n    \"Cabin\": There are 687 missing values around 77.10%. I will fill with Unknown \"U\".\n    \"Age\": we have 177 missing values. I think about 2 ways to deal with that. The easiest will be to replce the missing values by the average of age (dfAge[is.na(data\n\nAge)] <- mean(data$Age,na.rm=T)). I will do it that way,as name has no missing value, for a title containing a missing value I will assign the mean age value for each title not containing a missing value.\n\"Embarked\": We got 2 missing values so I can delete both rows but I decided to assign the two missing values to the most counted port (mode), which is Southampton (\"S\") in this case."},{"metadata":{"trusted":true,"_uuid":"441083743bf4a3ac5b6b8d7d36edd21a9b6bc372"},"cell_type":"code","source":"#extract the first letter of the \"Cabin\" variable\n#install.packages(\"stringr\", repos='http://cran.us.r-project.org')\nlibrary('stringr')\ndf$Cabin <- as.factor(str_sub(df$Cabin, 1, 1))\ndf_test$Cabin <- as.factor(str_sub(df_test$Cabin, 1, 1))\n\n# Missing values in \"Cabin\" attribute\nlevels(df$Cabin) <- c(levels(df$Cabin),'U')\ndf$Cabin[which(is.na(df$Cabin))] <- 'U'\n\nlevels(df_test$Cabin) <- c(levels(df$Cabin),'T', 'U')\ndf_test$Cabin[which(is.na(df_test$Cabin))] <- 'U'\n\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"bf21ec4e572e169824d59ea80c0a1d52299a956f"},"cell_type":"code","source":"#5 titles contained missing value Mr, Mrs, Miss, Dr & Master\n#assigning the mean age value for each title not containing a missing value\n\nmean_mr <- mean(df$Age[grepl(' Mr\\\\.',df$Name) & !is.na(df$Age)])\ndf$Age[grepl(' Mr\\\\.',df$Name) & is.na(df$Age)] <- mean_mr\n\nmean_mrs <- mean(df$Age[grepl(' Mrs\\\\.',df$Name) & !is.na(df$Age)])\ndf$Age[grepl(' Mrs\\\\.',df$Name) & is.na(df$Age)] <- mean_mrs\n\nmean_miss <- mean(df$Age[grepl(' Miss\\\\.',df$Name) & !is.na(df$Age)])\ndf$Age[grepl(' Miss\\\\.',df$Name) & is.na(df$Age)] <- mean_miss\n\nmean_dr <- mean(df$Age[grepl(' Dr\\\\.',df$Name) & !is.na(df$Age)])\ndf$Age[grepl(' Dr\\\\.',df$Name) & is.na(df$Age)] <- mean_dr\n\nmean_master <- mean(df$Age[grepl(' Master\\\\.',df$Name) & !is.na(df$Age)])\ndf$Age[grepl(' Master\\\\.',df$Name) & is.na(df$Age)] <- mean_master\n\n# Assigning the mode of 'Embarked' \ndf$Embarked[which(is.na(df$Embarked))] <- 'S'\n#contrasts(df$Embarked)For a better understanding of how R is going to deal with the categorical variables, \n#This function will show us how the variables have been dummyfied by R and how to interpret them in a model.","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"d8d51342dcb408659887f089f1bc43f6c0692adf"},"cell_type":"code","source":"# Test dataset\n#5 titles contained missing value Mr, Mrs, Miss, Dr & Master\n#assigning the mean age value for each title not containing a missing value\n\nmean_mr <- mean(df_test$Age[grepl(' Mr\\\\.',df_test$Name) & !is.na(df_test$Age)])\ndf_test$Age[grepl(' Mr\\\\.',df_test$Name) & is.na(df_test$Age)] <- mean_mr\n\nmean_mrs <- mean(df_test$Age[grepl(' Mrs\\\\.',df_test$Name) & !is.na(df_test$Age)])\ndf_test$Age[grepl(' Mrs\\\\.',df_test$Name) & is.na(df_test$Age)] <- mean_mrs\n\nmean_miss <- mean(df_test$Age[grepl(' Miss\\\\.',df_test$Name) & !is.na(df_test$Age)])\ndf_test$Age[grepl(' Miss\\\\.',df_test$Name) & is.na(df_test$Age)] <- mean_miss\n\nmean_ms <- mean(df_test$Age[grepl(' Ms\\\\.',df_test$Name) & !is.na(df_test$Age)])\ndf_test$Age[grepl(' Ms\\\\.',df_test$Name) & is.na(df_test$Age)] <- mean_dr\n\nmean_master <- mean(df_test$Age[grepl(' Master\\\\.',df_test$Name) & !is.na(df_test$Age)])\ndf_test$Age[grepl(' Master\\\\.',df_test$Name) & is.na(df_test$Age)] <- mean_master\n\ndf_test$Fare[which(is.na(df_test$Fare))] <- median(!is.na(df_test$Fare))","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"d10f5166b0703eaf802545aca5b0832c277ab519"},"cell_type":"markdown","source":"# Last formatting before proceeding to the fitting process"},{"metadata":{"trusted":true,"_uuid":"0bd8cb032f55406730eae71928b8a0264e102fb8"},"cell_type":"code","source":"#Let create a new column \"tilte\"\ndf$Title <- c(rep(NA, nrow(df)))\n\ndf$Title[grep(' Mr\\\\.',df$Name)] <- 'Mr'\ndf$Title[grep(' Mrs\\\\.',df$Name)] <- 'Mrs'\ndf$Title[grep(' Miss\\\\.',df$Name)] <- 'Miss'\ndf$Title[grep(' Ms\\\\.',df$Name)] <- 'Mrs'\ndf$Title[grep(' Mme\\\\.',df$Name)] <- 'Mrs'\ndf$Title[grep(' Rev\\\\.',df$Name)] <- 'Officer'\ndf$Title[grep(' Master\\\\.',df$Name)] <- 'Master'\ndf$Title[grep(' Mlle\\\\.',df$Name)] <- 'Miss'\ndf$Title[grep(' Dr\\\\.',df$Name)] <- 'Officer'\ndf$Title[grep(' Don\\\\.',df$Name)] <- 'Royalty'\ndf$Title[grep(' Dona\\\\.',df$Name)] <- 'Royalty'\ndf$Title[grep(' Lady\\\\.',df$Name)] <- 'Royalty'\ndf$Title[grep(' Col\\\\.',df$Name)] <- 'Officer'\ndf$Title[grep(' Capt\\\\.',df$Name)] <- 'Officer'\ndf$Title[grep(' Major\\\\.',df$Name)] <- 'Officer'\ndf$Title[grep(' the Countess\\\\.',df$Name)] <- 'Royalty'\ndf$Title[grep(' Jonkheer\\\\.',df$Name)] <- 'Royalty'\ndf$Title[grep(' Sir\\\\.',df$Name)] <- 'Royalty'\n\n\ndf$Title <- as.factor(df$Title)\nplot(df$Title)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"ff71f999cfcb15d3bdb37c1b6a20c3b20dbb4a97"},"cell_type":"code","source":"df_test$Title <- c(rep(NA, nrow(df_test)))\n\ndf_test$Title[grep(' Mr\\\\.',df_test$Name)] <- 'Mr'\ndf_test$Title[grep(' Mrs\\\\.',df_test$Name)] <- 'Mrs'\ndf_test$Title[grep(' Miss\\\\.',df_test$Name)] <- 'Miss'\ndf_test$Title[grep(' Ms\\\\.',df_test$Name)] <- 'Mrs'\ndf_test$Title[grep(' Mme\\\\.',df_test$Name)] <- 'Mrs'\ndf_test$Title[grep(' Rev\\\\.',df_test$Name)] <- 'Officer'\ndf_test$Title[grep(' Master\\\\.',df_test$Name)] <- 'Master'\ndf_test$Title[grep(' Mlle\\\\.',df_test$Name)] <- 'Miss'\ndf_test$Title[grep(' Dr\\\\.',df_test$Name)] <- 'Officer'\ndf_test$Title[grep(' Don\\\\.',df_test$Name)] <- 'Royalty'\ndf_test$Title[grep(' Dona\\\\.',df_test$Name)] <- 'Royalty'\ndf_test$Title[grep(' Lady\\\\.',df_test$Name)] <- 'Royalty'\ndf_test$Title[grep(' Col\\\\.',df_test$Name)] <- 'Officer'\ndf_test$Title[grep(' Capt\\\\.',df_test$Name)] <- 'Officer'\ndf_test$Title[grep(' Major\\\\.',df_test$Name)] <- 'Officer'\ndf_test$Title[grep(' the Countess\\\\.',df_test$Name)] <- 'Royalty'\ndf_test$Title[grep(' Jonkheer\\\\.',df_test$Name)] <- 'Royalty'\ndf_test$Title[grep(' Sir\\\\.',df_test$Name)] <- 'Royalty'\n\ndf_test$Title <- as.factor(df_test$Title)\nplot(df_test$Title)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"cb0a1d2e796797ec253da46d629661be06a2373f"},"cell_type":"markdown","source":"### Adding a new column family size"},{"metadata":{"trusted":true,"_uuid":"721f94fd949c1114fc254a9cb2cfe2f3056401e2"},"cell_type":"code","source":"df['FamSize'] = df['SibSp'] + df['Parch'] + 1\ndf_test['FamSize'] = df_test['SibSp'] + df_test['Parch'] + 1","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"bc69b92a47743cf0e4adc370304f8c6ff53a65a3"},"cell_type":"code","source":"","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"c9a78e4ffbb33fb17d2c6dc51dfa82c8ef1056b1"},"cell_type":"code","source":"# Using the subset() function to subset the original dataset selecting the relevant columns only.\n# I removed the following columns: PassengerId, Name, Ticket, Cabin\ndata <- subset(df,select=c(2,3,5,6,9,10, 11, 12, 13,14))\ndata_test <- subset(df_test,select=c(2,4,5,8,9,10,11,12,13))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"1b36d527483bcaaaf8887c63e625ef11e51f7441"},"cell_type":"code","source":"# Let's split the data dataset into dataing and test set.\nset.seed(100000)\ndata_index <- sample(nrow(data), floor(nrow(data)*0.7))\ntrain.set <- data[data_index,]\ntest.set <- data[-data_index,]","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"6b2eb4f9a206ff386639d66cedc4c9dabea9bb8d"},"cell_type":"markdown","source":"### Logistic Regression"},{"metadata":{"trusted":true,"_uuid":"0385ab4eba4061fc4a6a6ec57e77df786e71ec58"},"cell_type":"code","source":"# Logistic Regression Model\nlog_r <- glm(Survived~., data = train.set, family = binomial(link='logit'))\nsummary(log_r)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"d5dcc482f8ce5c5c9dc7ab0bff34f12d176bf570"},"cell_type":"code","source":"# Performance Evaluation: Confusion Matrix\npredicted <- predict(log_r, test.set[-1], type=\"response\")\npredicted_V1 <- ifelse(predicted>=0.55, 1, 0)\nconfusionMatrix_V1 <- table(actual = test.set$Survived, predicted = predicted_V1)\nconfusionMatrix_V1\naccuracy <- sum(diag(confusionMatrix_V1))/nrow(test.set)\nprint(paste('Accuracy =',accuracy))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"11845ccc26746df1458ad756c799a76af378738f"},"cell_type":"code","source":"#p <- predict(log_r, newdata=subset(test,select=c(2,3,4,5,6,7,8)), type=\"response\")\n#install.packages(\"ROCR\")\nlibrary(ROCR)\npr <- prediction(predicted, test.set$Survived)\nprf <- performance(pr, measure = \"tpr\", x.measure = \"fpr\")\nplot(prf)\n\nauc <- performance(pr, measure = \"auc\")\nauc <- auc@y.values[[1]]\nprint(paste('AUC =',auc))","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"4c32fbcb07cda3f29605f5953deaeee77905d6ee"},"cell_type":"markdown","source":"### Conditional Inference Random Forest"},{"metadata":{"trusted":true,"_uuid":"633bf3a00a1a20de8c9520475389d02d7c04ad31"},"cell_type":"markdown","source":"library('party')"},{"metadata":{"trusted":true,"_uuid":"4b020ed39fdde207d15f03d47ec236f8a4c9210d"},"cell_type":"markdown","source":"set.seed(100000)\nmodel <- cforest(as.factor(Survived) ~.,\n                 data = train.set, \n                 controls=cforest_unbiased(ntree=2000, mtry=3))"},{"metadata":{"trusted":true,"_uuid":"65b34fe9608efa2df0f6784313688ee721368996"},"cell_type":"markdown","source":"# Performance Evaluation: Confusion Matrix\npredicted <- predict(model, test.set[-1], OOB=TRUE, type = 'response')\nconfusionMatrix_V1 <- table(actual = test.set$Survived, predicted = predicted)\nconfusionMatrix_V1\naccuracy <- sum(diag(confusionMatrix_V1))/nrow(test.set)\nprint(paste('Accuracy =',accuracy))"},{"metadata":{"_uuid":"58fb954edba8ce96c7edaec21ff758412906665d"},"cell_type":"markdown","source":"# ROC curve\nIt is time to plot the ROC curve and calculate the AUC (area under the curve) which are typical performance measurements for a binary classifier.\nThe ROC is a curve generated by plotting the true positive rate (TPR) against the false positive rate (FPR) at various threshold settings while the AUC is the area under the ROC curve. As a rule of thumb, a model with good predictive ability should have an AUC closer to 1 (1 is ideal) than to 0.5."},{"metadata":{"trusted":true,"_uuid":"08eeb54fe3de42a1d24bcd0a1af068b8736c3d4b"},"cell_type":"markdown","source":"#install.packages(\"ROCR\")\nlibrary(ROCR)\npr <- prediction(as.numeric(predicted), test.set$Survived)\nprf <- performance(pr, measure = 'tpr', x.measure = 'fpr')\nplot(prf)\n\nauc <- performance(pr, measure = 'auc')\nauc <- auc@y.values[[1]]\nprint(paste('AUC =',auc))"},{"metadata":{"_uuid":"3f198b28eaa829a28493513c5c7b5e3e609f9cc9"},"cell_type":"markdown","source":"# Prediction with the test then submit to kaggle"},{"metadata":{"trusted":true,"_uuid":"8871bdba3c882dde9282270a1ffbf9cce14fc5cf","_kg_hide-output":true},"cell_type":"code","source":"\nsurvived_test <- predict(log_r,newdata= data_test,type = 'response')\nsurvived <- ifelse(survived_test>=0.55, 1, 0)\nsubmission = data.frame(cbind(df_test['PassengerId'], Survived = survived))\nwrite.csv(submission,'my_solution_LogReg.csv', row.names = FALSE)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"a1cc93dacbdbb8cb68ff70116e8e9f0c77105d5c"},"cell_type":"markdown","source":"### GridSearch"},{"metadata":{"trusted":true,"_uuid":"c2b559aecfa95c98941040cab3dd7d3dd8f963db"},"cell_type":"markdown","source":"library(caret)\nset.seed(100000)\nclassifier = train(form = as.factor(Survived) ~ .,\n                       data = train.set,\n                       method = 'cforest',\n                       controls=cforest_unbiased(ntree=2000))\nclassifier\nclassifier$bestTune\n"},{"metadata":{"trusted":true,"_uuid":"7a60b23f4ba8bd8cb08482e9698a049afe1fbf13"},"cell_type":"markdown","source":"predicted2 <- predict(classifier, test.set[-1], OOB=TRUE, type = 'raw')\nconfusionMatrix_V2 <- table(actual = test.set$Survived, predicted = predicted2)\nconfusionMatrix_V2\naccuracy <- sum(diag(confusionMatrix_V2))/nrow(test.set)\nprint(paste('Accuracy =',accuracy))"},{"metadata":{"trusted":true,"_uuid":"f91350cffb6dfa7946029aea71e97876a2a5db06"},"cell_type":"markdown","source":"library(ROCR)\npr2 <- prediction(as.numeric(predicted2), test.set$Survived)\nprf <- performance(pr2, measure = 'tpr', x.measure = 'fpr')\nplot(prf)\n\nauc2 <- performance(pr2, measure = 'auc')\nauc2 <- auc2@y.values[[1]]\nprint(paste('AUC =',auc2))"},{"metadata":{"trusted":true,"_uuid":"4e730a607b08b5aa088b05800016a9799acb68a4","_kg_hide-output":true},"cell_type":"markdown","source":"survived <- predict(classifier,newdata= data_test, OOB=TRUE, type = 'raw')\nsubmission2 = data.frame(cbind(df_test['PassengerId'], Survived = survived_test))\nwrite.csv(submission2,'my_solution_cforest2.csv', row.names = FALSE)"}],"metadata":{"kernelspec":{"display_name":"R","language":"R","name":"ir"},"language_info":{"mimetype":"text/x-r-source","name":"R","pygments_lexer":"r","version":"3.4.2","file_extension":".r","codemirror_mode":"r"}},"nbformat":4,"nbformat_minor":1}