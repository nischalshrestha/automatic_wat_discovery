{"cells":[{"metadata":{"_uuid":"645f4aeea018dd5a16e2499cd7da8c5c661a7c3f","_cell_guid":"b0bcb729-8939-43b3-8d38-775b79d20ed9"},"cell_type":"markdown","source":"**The Nuclear Family's Survival Guide**"},{"metadata":{"_uuid":"7cda872e6625ed2cfb2380c32099af8a583247ee","_cell_guid":"967836e5-ed20-4204-81bd-953e199aedbf","trusted":false},"cell_type":"code","source":"library(tidyr)\nlibrary(dplyr)\nlibrary(readr)\nlibrary(tree)\nlibrary(caret)\nlibrary(ggplot2) \nlibrary(readr)","execution_count":null,"outputs":[]},{"metadata":{"_kg_hide-output":true,"_cell_guid":"2918ba34-6746-41db-98ec-c154c9094f9f","_uuid":"3f9a167f597e8445f8d66ac77a27fbf596ffe371","_kg_hide-input":false,"trusted":false},"cell_type":"code","source":"titan.train <- read_csv(\"../input/train.csv\")\ntitan.test <- read_csv(\"../input/test.csv\")\n\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"745a8dfb866cfd790ecd782ea4918b5911262c45","_cell_guid":"b948dbb6-0be3-4b25-a855-bff2422a8071"},"cell_type":"markdown","source":"My First Kaggle submission, and obviously I'm very excited to see how accurate a model I can built!\n\n \n\nTrying to bring some form of originality to my Kernel, I thought it would interesting to see if being part of a family-unit, also known as the nuclear family, is a benefit or a burden in a life-or-death crisis. Society generally endorses the nuclear family as a bedrock of a stable community, promoting it as a more prosperous environment for children to grow up in and a more reliable unit in civic engagement than single individuals. What I'm curious to see if, in a lethal scenario such as being on a sinking ship, does one benefit from being in a group that is concerned about your survival, or does the family unit slow you down when time is of essence. \n\nThere are 5 parts to my markdown as follows:\n\n\n**DATA CLEANING\n\nFEATURE ENGINEERING\n\nEXPLORATORY ANALYSIS\n\nMODEL INTERPRATATION\n\nPREDICTION**\n \n\n\n"},{"metadata":{"_uuid":"fe7fb01aaaa7912a38f00c496bb35a79e3447025","_cell_guid":"01957d61-48dd-4c5e-b884-a85610f314c2"},"cell_type":"markdown","source":"**DATA CLEANING**"},{"metadata":{"_uuid":"ab10f7629120db4d5639fc2d3f5b246aa98042b9","_cell_guid":"1b286032-ba05-491e-9c98-8293bc78b0ec"},"cell_type":"markdown","source":"First thing I want to do is take care of all NA values in the dataset. My aim is to identify which variables have NA values, and based on how many values in the column are missing I will assume what best strategy to replace these NA values."},{"metadata":{"_uuid":"81d4477315c9fe1e61d8392ff927fb789f26df33","_cell_guid":"3dcab807-49ab-44e7-861d-a8cfae982004","trusted":false},"cell_type":"code","source":"### check which columns have na values\n\ncolnames(titan.train)[ apply(titan.train, 2, anyNA) ]\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"32c3c363f35a08d8ed385f8b140de7bb80ad8530","_cell_guid":"1c0db78b-275d-46ad-8d3b-458587e5a7ee","trusted":false},"cell_type":"code","source":"###count number of na rows in those columns\n\nsum(is.na(titan.train$Cabin))\nsum(is.na(titan.train$Embarked))\nsum(is.na(titan.train$Age))\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"027cc85be47788fdcf0e1e7e83d4cdf38657fc29","_cell_guid":"542808ab-16c8-4a27-8501-65c92c499b43"},"cell_type":"markdown","source":"The Cabin column has 687 values missing, Embarked has 2 missing values, and Age has 177 missing values. I decided to drop the Cabin column, since it was missing 687 out of 889 variables, and I also dropped the two observations with NA values in Embarked. For the Age missing values, I decide to replace the value with median age of passengers. \n"},{"metadata":{"_uuid":"8f5df7040331b7771d43a02c424126769d7f49d5","_cell_guid":"c54255fd-5126-4dce-9473-69ddf6ec62fe","trusted":false},"cell_type":"code","source":"############ drop cabin, give most common value to embarked and give them median age\n\ntitan.train$Cabin <- NULL\n\ntable(titan.train$Embarked)\n\ntitan.train <- titan.train%>% drop_na(Embarked)\n\n\ntitan.train <- titan.train %>% mutate_at(vars(Age), ~ifelse(is.na(.), median(., na.rm = TRUE), .))\n\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"78adf1a83ff83fec24135392d99e61d460cb993d","_cell_guid":"fcfb3d51-3121-456b-b081-caabad5a763e"},"cell_type":"markdown","source":"**FEATURE ENGINEERING**"},{"metadata":{"_uuid":"97d97b0e545e8ebea8f40281af4f14175bd78fa2","_cell_guid":"21d7731a-9563-4c41-a7fd-f33fb49d3d7e"},"cell_type":"markdown","source":"\nTo measure the impact that being part of a nuclear - family has on a passenger, I have to create a variable that indicated if a person is traveling as a family or not. The new variables, NukeFM_or_Not, marks a passenger as part of a family if this person is traveling with at least one sibling and 1 parent (Disclaimer: According to wikipedia a nuclear-family is a couple with at least one dependent child, meaning two siblings traveling with one parents would be classified as a family unit but would not technically be a nuclear family)."},{"metadata":{"_uuid":"058d6e9ab494853a5d0c729291ea3a997b7d9833","_cell_guid":"cbd33216-989b-42a7-9da0-b378591f0822","trusted":false},"cell_type":"code","source":"#Family unit or not\n\ntitan.train$NUKEFM_or_Not <- ifelse( titan.train$SibSp >=1 & titan.train$Parch >= 1,1,0)\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"a314afa786ce6babfd2556e668495cd473b1da5b","_cell_guid":"31fe37c5-b94b-4b2c-8f33-53f0dac91212"},"cell_type":"markdown","source":"Looking through the  passenger titles, I noticed that while it would be hard to seperate married men traveling alone from bachelors, I could use the \"Miss\" title to identify single women over 18. This could help me discern the survival differences between being single in a time of crisis and being married. "},{"metadata":{"_uuid":"5b08ccfceb161237fc257dec80270a1db700fe9e","_cell_guid":"7f1dec54-47ec-4b9c-8300-fb532288b7ac","trusted":false},"cell_type":"code","source":"########## create a variable that designates if they are a family/nuclear family\n\n# \ntitan.train$Miss_or_Not <- ifelse(grepl(\"Miss\",titan.train$Name) & titan.train$Age > 18, 1,0 ) \n\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"ab91a3cec0e5b866998c28adfcf83914addbeeb5","_cell_guid":"c9f9b221-c7f9-4584-8f3a-bee9d7098508"},"cell_type":"markdown","source":"An additional variable that could impact survival is family size. A large family can be slower to move as a unit. "},{"metadata":{"_uuid":"18c5c4097da52e097a1c10f96763a019be239f5c","_cell_guid":"045626a1-6554-40b1-bb36-b2baac096d62","trusted":false},"cell_type":"code","source":"# Create new column  family_size\ntitan.train$family_size <- titan.train$SibSp + titan.train$Parch + 1","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"7d4146657987bc4a56585b85a179aab40a7f9925","_cell_guid":"c60d60d0-e1a3-4027-993c-3a440bc73dcb"},"cell_type":"markdown","source":"**EXPLORATORY ANALYSIS**\n\n"},{"metadata":{"_uuid":"e2e5a0d7d0cb40fb38b5804126f9552ab85650e7","_cell_guid":"151305bc-b384-4189-90b0-83340dffa781"},"cell_type":"markdown","source":"Comparing the breakdown of the survival rate across the Family-related attributes."},{"metadata":{"_uuid":"b8c45cd1209db818f06c93cc98757027a951cffb","_cell_guid":"a013a60e-a62f-48ec-b757-c00915e1e5ca","trusted":false},"cell_type":"code","source":"#### Plot survival rate of people traveling as a family unit vs. not\n\n\n\n\ndat <- data.frame(table(titan.train$NUKEFM_or_Not,titan.train$Survived))\nnames(dat) <- c(\"NUKEFM_or_Not\",\"Survived\",\"Survival_Rate\")\n\n\nggplot(data=dat, aes(x=NUKEFM_or_Not, y=Survival_Rate, fill=Survived)) + geom_bar(stat=\"identity\",position = \"fill\")\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"11a6914487e09581863b1a5aa72bdb312e418650","_cell_guid":"9c121327-d80b-4495-a4f1-502bbf1f89d9"},"cell_type":"markdown","source":"The bar looks at the survival of passengers who were identified as traveling with a family unit( marked 1) versus those who weren't (marked 0). While the difference isn't major, we see that the survival rate for passengers that were part of a family unit is slighty higher than for those that aren't, by about 5%.\n\n"},{"metadata":{"_uuid":"666239f32c4ddaace6f81c2b595dc05d2929658f","_cell_guid":"7555da3c-a391-4923-b746-2ba2f3a3fc50","trusted":false},"cell_type":"code","source":"###### Plot survival rate of married female adult passengers vs. non-married female adult passengers\n\n################## Following the advice of David Robinson, the following code was commented out to a more simple syntax that used count() instead of data.frame(table()) ##############\n\n\n# s <- titan.train %>% filter( Sex == \"female\")  %>% filter(Age > 18)  \n#dam <- data.frame(table(s$Miss_or_Not,s$Survived))\n#names(dam) <- c(\"Miss_or_Not\",\"Survived\",\"Survival_Rate\")\n\n#s <- dam %>% group_by(Miss_or_Not) %>% summarize(total = sum(Survival_Rate))\n\n#dam <- left_join(dam,s, by=\"Miss_or_Not\")\n\n#dam$Percent <- dam$Survival_Rate/dam$total*100\n\n############################################## \n\ns <- titan.train %>% filter( Sex == \"female\")  %>% filter(Age > 18)  \n\ndam <- s %>% filter(!is.na(Miss_or_Not)) %>% count(Miss_or_Not, Survived) %>% group_by(Miss_or_Not) %>% mutate(total=sum(n),Percent = n / total *100)\n\nnames(dam) <- c(\"Miss_or_Not\",\"Survived\",\"Survival_Rate\", \"total\", \"Percent\")\n\n dam$Survived <- as.factor(dam$Survived)\ndam$Miss_or_Not <- as.factor(dam$Miss_or_Not)\n\nggplot(data=dam, aes(x=Miss_or_Not, y=Survival_Rate, fill=Survived)) + geom_bar(stat=\"identity\",position = \"fill\")\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"856a4747346b99dd770e771159a1d6f5de0fb583","_cell_guid":"e0b28ede-d54a-408b-ba9d-157dd6176303"},"cell_type":"markdown","source":"For the Miss_or_Not varibale, the bar chart shows that the suvival rate amongst female adult passengers was lower for women with the title \"Miss\" (marked 1) than for women with the title \"Mrs\" by about 7-10% (marked 0).  Over 25% of women titled \"Miss\" did not survived, while for married women the rate was around 20%."},{"metadata":{"_uuid":"862e3dfe100d5db40700cc5d9cfa471556d6d74e","_cell_guid":"e71e76fb-f6ba-432e-976f-fd7432cf6084","trusted":false},"cell_type":"code","source":" ##### plot the sruvival rate of each family size\n\ndank <- data.frame(table(titan.train$family_size,titan.train$Survived))\nnames(dank) <- c(\"Family_size\",\"Survived\",\"Survival_Rate\")\n\n\n\nggplot(data=dank, aes(x=Family_size, y=Survival_Rate, fill=Survived)) + geom_bar(stat=\"identity\",position = \"fill\")\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"52dd463e1708e61e3300fc4ff5ca81a2130fa832","_cell_guid":"e788038a-2c0d-4ccf-8ef8-7c613ab08df7"},"cell_type":"markdown","source":"This might be the most interesting graph, as it seems to show that, between the family size of 1 and 4, the survival rate goes up for every additional family member. For a family bigger than 4, the survival rate plummets."},{"metadata":{"_uuid":"4097cbcf7c25bcfcccc422054c19b417e7fe7b53","_cell_guid":"23d3d117-2e4b-4e97-9472-a2efbfaef644","trusted":false},"cell_type":"code","source":"####### Turn the Ticket variable to a numerical\n\n\ntitan.train$Ticket <- gsub(\"^.*\\\\s\", \"\", titan.train$Ticket)\n\ntitan.train$Ticket <- as.numeric(titan.train$Ticket)\n\n######## turn survived into a factor\n\ntitan.train$Survived <- factor(titan.train$Survived, levels = c(0,1))\ntitan.train$Pclass <- factor(titan.train$Pclass, levels = c(3,2,1), ordered = TRUE)\ntitan.train$Sex<- as.factor(titan.train$Sex)\ntitan.train$Embarked <- as.factor(titan.train$Embarked)\ntitan.train$Miss_or_Not <- as.factor(titan.train$Miss_or_Not)\ntitan.train$NUKEFM_or_Not <- as.factor(titan.train$NUKEFM_or_Not)\n\n####### Remove name \n\ntitan.train$Name <- NULL","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"75e8da3f23718a57abceac5e32819279173409e4","_cell_guid":"8facd1c6-e4ff-40b6-869d-7536eedc2776"},"cell_type":"markdown","source":"Here I continue with my feature engineering, this time by tranforming the Ticket variable into a numerical variable. I proceed to also factorize every other non-numerical variable, since most ML algorithms don't do well with categorical variables. Also, I remove the Name feature as I figure being called Michael over Thomas probably doesn't affect your survival rate. "},{"metadata":{"_uuid":"efa0b6592aefc902eee87bef7f0d3eb8f024c94d","_cell_guid":"479e91ef-1e53-4725-b641-5a00a57495cc"},"cell_type":"markdown","source":"Applying Decion Tree Model"},{"metadata":{"_uuid":"2d6f2b7b94c0af0e1a5ec87aa30b45cfebb09f68","_cell_guid":"67dd7fae-6462-438d-bfc6-415e7f61a32f"},"cell_type":"markdown","source":"With this Kernel, my goal is to create a model that is easy to interpet. For this reason I chose the decision tree. While I do realize that a Bagging or Random Forest approach would give me a better accuracy, those models are not as easy to interpret."},{"metadata":{"_uuid":"b7dff26b743ea25db614d4ea5eb308f54f1dd0ed","_cell_guid":"a79fbcba-b1de-4f68-be7f-d8b4621c2f23","trusted":false},"cell_type":"code","source":"###################### create a decision tree ###################### \n\n### Split Data into training and validation set\nset.seed(123)\ninTrain <- sample(nrow(titan.train), 0.75*nrow(titan.train))\n#\ntrain <- data.frame(titan.train[inTrain,])\nvalidation <- data.frame(titan.train[-inTrain,])\n## training a decion tree algorithm on the training set\n\n\ntree.titanic=tree(Survived~.-PassengerId,data=train)\n\n\n### How would the model do on the validation set?\n\n\n\ntree.pred=predict(tree.titanic,validation,type=\"class\")\nconfusion = table(tree.pred,validation$Survived)\nconfusion\n\n\n# Computing the error rate on the validation data (full tree)\n\nError = (confusion[1,2]+confusion[2,1])/sum(confusion)\nError\n\n(accuracy <- (confusion[1,1]+confusion[2,2])/sum(confusion))\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"465a2e47cb6387258760470bd7f3907c4e635292","_cell_guid":"d3b1001d-910b-499b-8d8c-a50e824d98f8"},"cell_type":"markdown","source":"When creating a decision tree (or any ML algorithm in general), there is always the concern that the model will overfit the training set. To mitigate this, I use a  popular method called pruning the tree. In brief, Pruning refers to splitting the training data set into a validation set, training the decision tree on the training set and then using the validation set to prune back (cut branches off) the full grown tree and identifiying the best tree with the least number of branches without sacrificing accuracy.  \n\nNote,  the performance of the initial  tree on the validation data is not fully reflective of the performance on completely new data.\n"},{"metadata":{"_uuid":"3469e20a91aabf7c1424434b8bfe9fa9957e8f37","_cell_guid":"c720d1df-7fbd-40b5-8579-c1167abe224c","trusted":false},"cell_type":"code","source":"\nSize <- 1:10\nError <- rep(0,length(Size))\n\n# For tree with one terminal node the prediction is the modal class\ntable(validation$Survived)\n# There are 50 \"Yes\" and 134-50 \"High\"\n(Error[1] = 50/134)\n\nlibrary(caret)\n\nfor (i in 2:10) {\n  prune.titanic=prune.misclass(tree.titanic,best=i)\n  tree.pred=predict(prune.titanic,validation,type=\"class\")\n  confusion = table(tree.pred,validation$Survived)\n  Error[i] = (confusion[1,2]+confusion[2,1])/sum(confusion)\n}\n\nplot(Size,Error,type = \"o\",xlab=\"Tree Size\",ylab=\"Error Rate\",col=\"blue\")\n(z = which.min(Error))\n#\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"07cde48317ed24bf0df54ad3c47e13b941009f2b","_cell_guid":"fac0ea83-1bcb-4036-9c41-f72b6253839b"},"cell_type":"markdown","source":"We notice that once the tree reaches 5 decision nodes there is no improvement on the error rate, indicating that creating a tree of more than 5 decicion nodes would be overfitting. Now, we plot the tree. "},{"metadata":{"_uuid":"1524006e84197b41cc10cca027f9bdbe683196d0","_cell_guid":"21f3ae3c-fa47-4815-ba19-a42161151da6","trusted":false},"cell_type":"code","source":"# Now plot the best pruned tree\nprune.titanic=prune.misclass(tree.titanic,best=z)\nplot(prune.titanic)\ntext(prune.titanic,pretty=0)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"ceb2ffd2b78bd04fa6e082bf5d1ae31cabc3f4d4","_cell_guid":"dcfad160-e135-4270-8c25-8c90547dc46e"},"cell_type":"markdown","source":"**MODEL INTERPRATION**"},{"metadata":{"_uuid":"f40ca051cbfab7ca8f610174df00c9907b26c2cb","_cell_guid":"faeac08b-3552-4d9a-adc1-9485be082334"},"cell_type":"markdown","source":"The first thing I notice is that the pruned tree  does not consider my engineered features for predictive purposes.  Judging from the tree, is seems gender is the primary influencial feature in predicting survival rate. The tree predicts that only female passengers who were traveling in third class and embarked on Southampton perished, every other female passenger is likely to have survived. For male passengers, the algorithm predicts that every passenger traveling in second or thrid class, and over the age of 13, is unlikely to have survived. "},{"metadata":{"_uuid":"8fe81471604c94e3f610a95921b689a7f6e8a3bb","_cell_guid":"ee6bedec-ddc3-40a6-9c57-7c1594b24934"},"cell_type":"markdown","source":"**DEALING WITH TEST SET**"},{"metadata":{"_uuid":"e0414bba83ab3841f8a9514a9ce646d6e0932230","_cell_guid":"5ecf8df0-7bc6-4d96-8e67-3fe49518c8c8"},"cell_type":"markdown","source":"Now I have to find the NA values in the test set and decide how to deal with them. "},{"metadata":{"_uuid":"6486f4598e924f40a130ab2a25d853dee4d311c4","_cell_guid":"fa13e46e-dbae-443b-9bcb-a2aa347c308c","trusted":false},"cell_type":"code","source":"#####################################\n\n\ncolnames(titan.test)[ apply(titan.test, 2, anyNA) ]\n\n\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"5863f9c08a76ed7717b19e880b8c47aa77dba17c","_cell_guid":"948a52f2-f952-4c14-82ec-16346136283f"},"cell_type":"markdown","source":"It seems Age, Fare and Cabin have NA values. "},{"metadata":{"_uuid":"26303d746d89346e8a38b7304766125ac136fddc","_cell_guid":"a353f0df-e49f-4f69-b5d9-c04d0e6a8428","trusted":false},"cell_type":"code","source":"###count number of na rows in those columns\n\nsum(is.na(titan.test$Age))\nsum(is.na(titan.test$Fare))\nsum(is.na(titan.test$Cabin))\n\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"efd112736c26f0a99234f6e7042ec4d86eb32557","_cell_guid":"88a51be7-4e4e-43a7-bdf2-d4622640668b"},"cell_type":"markdown","source":"Age has 86 NA values, Fare has 1 NA value, and Cabin has 327 Na values. Similar to what I did with the training set, I'll drop the cabin column. I'll input the median Fare and Age values in each respective missing NA value.  I'll create similar features, Miss_or_Not and NukeFM_or_Not. I'll also factorize the categorical vairables . "},{"metadata":{"_uuid":"645afcdbfd3173bd58077644063ccf4e4b5502f7","_cell_guid":"3ba8c380-c55d-4567-8be2-b5258b31231b","trusted":false},"cell_type":"code","source":"#### MAKE cabin null, median value for the Fare and median for the Age\ntitan.test$Cabin <- NULL\n\ntitan.test <- titan.test %>% mutate_at(vars(Age), ~ifelse(is.na(.), median(., na.rm = TRUE), .))\n\ntitan.test <- titan.test %>% mutate_at(vars(Fare), ~ifelse(is.na(.), median(., na.rm = TRUE), .))\n\n# create Miss_or_Not and FM \n\ntitan.test$Miss_or_Not <- ifelse(grepl(\"Miss\",titan.test$Name) & titan.test$Age > 18, 1,0 ) \n\n\n#Family unit or not\n\ntitan.test$NUKEFM_or_Not <- ifelse( titan.test$SibSp >=1 & titan.test$Parch >= 1,1,0)\n\n# Create new column -> family_size\ntitan.test$family_size <- titan.test$SibSp + titan.test$Parch + 1\n\n####### Turn the Ticket variable to a numerical\n\ntitan.test$Ticket <- gsub(\"^.*\\\\s\", \"\", titan.test$Ticket)\n\ntitan.test$Ticket <- as.numeric(titan.test$Ticket)\n\n######## turn survived into a factor\n\n#stitan.test$Survived <- factor(titan.test$Survived, levels = c(0,1))\ntitan.test$Pclass <- factor(titan.test$Pclass, levels = c(3,2,1), ordered = TRUE)\ntitan.test$Sex<- as.factor(titan.test$Sex)\ntitan.test$Embarked <- as.factor(titan.test$Embarked)\ntitan.test$Miss_or_Not <- as.factor(titan.test$Miss_or_Not)\ntitan.test$NUKEFM_or_Not <- as.factor(titan.test$NUKEFM_or_Not)\n\n\n####### Remove name \n\ntitan.test$Name <- NULL\n\n\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"7fe1506d42a8d41f8a9a30b0e075aff00cc532af","_cell_guid":"75db4bb1-8d69-41d0-bbfb-6e307a12a2f4"},"cell_type":"markdown","source":"**PREDICTION**"},{"metadata":{"_uuid":"6c111a77baebdc6184da3020e0ab2ac736ce5b49","_cell_guid":"bc91c300-603c-4775-ad33-a8fd08c623bc","trusted":false},"cell_type":"code","source":"\n######## attach prediction to test set\ntree.pred=predict(prune.titanic,titan.test,type=\"class\")\n\ntitan.test$Survived <- tree.pred\n\nKaggle.submit <- titan.test %>% select(\"PassengerId\", \"Survived\")\n\n#write.csv(Kaggle.submit, file = \"../input/submit.csv\", row.names=FALSE)\n\n","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"23bbe8cc9e0e2bd054f73d38f70da88d04075da0","_cell_guid":"e803939d-5a4a-45be-9ef4-d6d2cf9f69ea"},"cell_type":"markdown","source":"Once submitted, the model received a 78.947% accuracy score.  Not bad for a simple decision tree. \n\n"},{"metadata":{"_uuid":"84120963afbc094f5bd33698744936fb11ff22c1","_cell_guid":"bc54132a-d709-4b03-a8ed-33afffd3c474","trusted":false},"cell_type":"code","source":"","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"db7858ed222d98fd4f7a70917283b4c0094bb5a1","_cell_guid":"3a902016-2a54-47c2-a3b2-fa4aa859ff0e","trusted":false},"cell_type":"code","source":"","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"5f044261196b855a88098ba569f5c6ed317adbce","_cell_guid":"38a2f0a8-9c1f-4096-9a3c-79c2c213086d","trusted":false},"cell_type":"code","source":"","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"3c33a87ceb5d2d4b14f0c2d78f25369bf615d985","_cell_guid":"46163a48-404f-4d56-9ee2-0cc1b77642aa"},"cell_type":"markdown","source":""}],"metadata":{"kernelspec":{"display_name":"R","language":"R","name":"ir"},"language_info":{"mimetype":"text/x-r-source","name":"R","pygments_lexer":"r","version":"3.4.2","file_extension":".r","codemirror_mode":"r"}},"nbformat":4,"nbformat_minor":1}