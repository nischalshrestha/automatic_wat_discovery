{"cells":[{"metadata":{"_uuid":"8f2839f25d086af736a60e9eeb907d3b93b6e0e5","_cell_guid":"b1076dfc-b9ad-4769-8c92-a6c4dae69d19","trusted":true,"collapsed":true},"cell_type":"markdown","source":"# Jetbrain Day Kr 2018 - Titanic Prediction (XGBoost will tell us!)\n\nThanks, Chris Deotte, Hitesh palamada 감사합니다. \n해당 커널 작성한 [Chris Deotte](https://www.kaggle.com/cdeotte), [Hitesh palamada](https://www.kaggle.com/hiteshp) 덕분에 Jetbrain day KR 2018 캐글뽀개기 튜토리얼을 진행할 수 있었습니다. \n\n이번 커널은 다음의 3개 커널을 주로 참고 했습니다.\n\n\n[Titantic Mega Model- 0.84210](https://www.kaggle.com/cdeotte/titantic-mega-model-0-84210)\n\n[Titanic WCG+XGBoost - 0.84688](https://www.kaggle.com/cdeotte/titanic-wcg-xgboost-0-84688)\n\n[Head Start for Data Scientist](https://www.kaggle.com/hiteshp/head-start-for-data-scientist)"},{"metadata":{"_uuid":"1d514552aeee76efc362f6873e775beceacb2d45"},"cell_type":"markdown","source":""},{"metadata":{"_uuid":"08552a67026efa5adbaa7440da7278adeea51bcb"},"cell_type":"markdown","source":"## Titanic Tutorial (Head Start for Data Scientist)\n-  [Head Start for Data Scientist](https://www.kaggle.com/hiteshp/head-start-for-data-scientist)\n\n-  1912 년 4 월 14 일 타이타닉 호는 거대한 빙산을 쳤고 승객과 승무원의 약 1,500 명을 대서양의 얼음 깊이 아래로 데려갔습니다. \n- 바다에서의 최악의 재해 중 하나인 타이타닉은 비극적인 사건으로 인해 그러한 재앙이 다시 발생하는 것을 방지하기 위한 수많은 안전 규정과 정책이 만들어졌습니다. \n- 그러나 일부 비평가들은 운이 아닌 다른 상황으로 인해 사망자 수가 불균형을 빚었다고 주장합니다. 이 분석의 목적은 사람의 생존 가능성에 영향을 미치는 요소를 탐색하는 것\n\n**#### Import library’s, data"},{"metadata":{"trusted":true,"_uuid":"e8bad8c98efaa8457173764e6e3a4e66175536d9"},"cell_type":"code","source":"pacman::p_load(rpart, tidyverse, gridExtra, xgboost, forcats, stringr, caTools, DT, data.table, pander, scales, grid, corrplot, VIM, knitr, vcd, caret, MLmetrics, randomForest, \n              rpart.plot, car, e1071, ROCR, pROC, glmnet)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"6be880e4ecfdfb102745fbdf2a03fa0520f31232"},"cell_type":"code","source":"getwd()","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"350667365af855603274846259e1a6b699d31521"},"cell_type":"code","source":"list.files('../input/')","execution_count":null,"outputs":[]},{"metadata":{"_cell_guid":"79c7e3d0-c299-4dcb-8224-4455121ee9b0","_uuid":"d629ff2d2480ee46fbb7e2d37f6b5fab8052498a","trusted":true,"_kg_hide-input":true},"cell_type":"code","source":"train <- read_csv(file = '../input/titanic/train.csv')\ntest <- read_csv(file = '../input/titanic/test.csv')","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"8f7a7251c6dfd5c7865da439d418f6e21093513a"},"cell_type":"markdown","source":"| Variable  | Definition | key |\n| :------------ | :-----------: | :-----------: |\n| survival | 생존 유무 | 0  = No, 1 = Yes |\n| pclass | 티켓 클래스 | 1 = 1st, 2 = 2nd, 3 = 3rd |\n| sex | 성별 ||\n| Age | 나이 ||\n| sibsp | 형제 & 배우자 숫자||\n| parch | 부모님 & 아이들 숫자 ||\n| ticket | 티켓 번호 ||\n| fare | 요금 ||\n| cabin | 객실 번호 ||\n| embarked | 승선항 |C = Cherbourg, Q = Queenstown, S = Southampton|\n\n"},{"metadata":{"trusted":true,"_uuid":"89fc5efd2b3f45d8a6399446a7154c7950549494"},"cell_type":"code","source":"train$set <- \"train\"\ntest$set  <- \"test\"\ntest$Survived <- NA\nfull <- rbind(train, test)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"eef45397c1eef5393c9ee61affa45b3d8489a323"},"cell_type":"code","source":"str(full)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"c8c046423039ea4ddf462cf272356af851eebaea"},"cell_type":"code","source":"glimpse(full)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"eda296301c7fbd68ada0b54bdfd98d71162278b5"},"cell_type":"code","source":"summary(full)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"1ed9076b4e20eda971a8156bde81ddaa4062d04a"},"cell_type":"code","source":"str(test)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"b017994adde5c138ad2eb11d4d70c9b81f21f477"},"cell_type":"code","source":"dim(full)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"ea066312de060e1ad8f4b830ef152c9cec59617b"},"cell_type":"code","source":"# Unique values per column\nsapply(full, function(x) length(unique(x)))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"98b7c463fc4a5e09cf4950a603d8e9fc9913b21b"},"cell_type":"code","source":"#Check for Missing values\nmissing_values <- full %>% summarize_all(funs(sum(is.na(.))/n()))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"97733d6ac3e3dd9114cf8f4c5e8349174ce2cd30"},"cell_type":"code","source":"missing_values <- gather(missing_values, key=\"feature\", value=\"missing_pct\")\nmissing_values %>% \n  ggplot(aes(x=reorder(feature,missing_pct),y=missing_pct)) +\n  geom_bar(stat=\"identity\",fill=\"red\")+\n  coord_flip()+theme_bw()","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"2e1d120d46ddd4b98e9a5af2291ecd65bd3dd454"},"cell_type":"code","source":"checkColumn = function(df,colname){\n  testData = df[[colname]]\n  numMissing = max(sum(is.na(testData)|is.nan(testData)|testData==''),0)\n  if (class(testData) == 'numeric' | class(testData) == 'Date' | class(testData) == 'difftime' | class(testData) == 'integer'){\n    list('col' = colname,'class' = class(testData), 'num' = length(testData) - numMissing, 'numMissing' = numMissing, 'numInfinite' = sum(is.infinite(testData)), 'avgVal' = mean(testData,na.rm=TRUE), 'minVal' = round(min(testData,na.rm = TRUE)), 'maxVal' = round(max(testData,na.rm = TRUE)))\n  } else{\n    list('col' = colname,'class' = class(testData), 'num' = length(testData) - numMissing, 'numMissing' = numMissing, 'numInfinite' = NA,  'avgVal' = NA, 'minVal' = NA, 'maxVal' = NA)\n  }\n}\n\ncheckAllCols = function(df){\n  resDF = data.frame()\n  for (colName in names(df)){\n    resDF = rbind(resDF,as.data.frame(checkColumn(df=df,colname=colName)))\n  }\n  resDF\n}\n\ncheckAllCols(full)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"a68938ab26725a566bd9cb05c988bb2e688422cd"},"cell_type":"code","source":"miss_pct <- map_dbl(full, function(x) { round((sum(is.na(x)) / length(x)) * 100, 1) })\nmiss_pct <- miss_pct[miss_pct > 0]\n\ndata.frame(miss=miss_pct, var=names(miss_pct), row.names=NULL) %>%\n    ggplot(aes(x=reorder(var, miss), y=miss)) + \n    geom_bar(stat='identity', fill='red') +\n    labs(x='', y='% missing', title='Percent missing data by feature') +\n    theme(axis.text.x=element_text(angle=90, hjust=1))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"c5602ae10d5ce0345dfbe57406f34d2943306548"},"cell_type":"code","source":"full <- full %>%\n    mutate(\n      Age = ifelse(is.na(Age), mean(full$Age, na.rm=TRUE), Age),\n      `Age Group` = case_when(Age < 13 ~ \"Age.0012\", \n                                 Age >= 13 & Age < 18 ~ \"Age.1317\",\n                                 Age >= 18 & Age < 60 ~ \"Age.1859\",\n                                 Age >= 60 ~ \"Age.60Ov\"))\n\ntable(full$`Age Group`)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"040f0ce215182b6f918d297b625f4e729dbeda32"},"cell_type":"code","source":"full$Embarked <- replace(full$Embarked, which(is.na(full$Embarked)), 'S')\ntable(full$Embarked)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"5162b7a8bb31d3913bb3ac9711c9a6a32f31637f"},"cell_type":"code","source":"names <- full$Name\ntitle <-  gsub(\"^.*, (.*?)\\\\..*$\", \"\\\\1\", names)\nfull$title <- title\ntable(title)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"bbc6c20e6c4c50e46b61f3a28e7d90e7a871ce90"},"cell_type":"code","source":"### MISS, Mrs, Master and Mr은 더 많은 숫자를 사용하고 있습니다.\n### 성별과 생존율을 확인하여 다른 과목을 더 큰 바구니에 그룹화하는 것이 더 좋음\n\nfull$title[full$title == 'Mlle']        <- 'Miss' \nfull$title[full$title == 'Ms']          <- 'Miss'\nfull$title[full$title == 'Mme']         <- 'Mrs' \nfull$title[full$title == 'Lady']          <- 'Miss'\nfull$title[full$title == 'Dona']          <- 'Miss'\n\n# 나는 작은 데이터로 새로운 변수를 생성하는 것이 overfit을 야기 할 수 있다고 생각한다.\n\nfull$title[full$title == 'Capt']        <- 'Officer' \nfull$title[full$title == 'Col']        <- 'Officer' \nfull$title[full$title == 'Major']   <- 'Officer'\nfull$title[full$title == 'Dr']   <- 'Officer'\nfull$title[full$title == 'Rev']   <- 'Officer'\nfull$title[full$title == 'Don']   <- 'Officer'\nfull$title[full$title == 'Sir']   <- 'Officer'\nfull$title[full$title == 'the Countess']   <- 'Officer'\nfull$title[full$title == 'Jonkheer']   <- 'Officer'  ","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"7554fcdb477bd2d49b810e6c5dbab5d6b1d38d21"},"cell_type":"code","source":"table(full$title)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"5e0ee917fe85c1aa9edbd940dfecb717b6510003"},"cell_type":"code","source":"full$FamilySize <-full$SibSp + full$Parch + 1 \nfull$FamilySized[full$FamilySize == 1] <- 'Single' \nfull$FamilySized[full$FamilySize < 5 & full$FamilySize >= 2] <- 'Small' \nfull$FamilySized[full$FamilySize >= 5] <- 'Big' \nfull$FamilySized=as.factor(full$FamilySized)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"f1a2135efbac75447041ca9e2667b86f8badc6a0"},"cell_type":"code","source":"plot(full$FamilySized)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"514b8ffb9a8b474cc06c9c9c535ba62dfcf07275"},"cell_type":"code","source":"##Engineer features based on all the passengers with the same ticket\nticket.unique <- rep(0, nrow(full))\ntickets <- unique(full$Ticket)\n\nfor (i in 1:length(tickets)) {\n  current.ticket <- tickets[i]\n  party.indexes <- which(full$Ticket == current.ticket)\n  for (k in 1:length(party.indexes)) {\n    ticket.unique[party.indexes[k]] <- length(party.indexes)\n  }\n}\n\nfull$ticket.unique <- ticket.unique\nfull$ticket.size[full$ticket.unique == 1]   <- 'Single'\nfull$ticket.size[full$ticket.unique < 5 & full$ticket.unique>= 2]   <- 'Small'\nfull$ticket.size[full$ticket.unique >= 5]   <- 'Big'\n\ntable(full$ticket.size)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"c584aa3e102aca5d87656c1e1cfa792ecdcf0e30"},"cell_type":"code","source":"full <- full %>%\n mutate(Survived = case_when(Survived==1 ~ \"Yes\", \n                              Survived==0 ~ \"No\"))\n\ncrude_summary <- full %>%\n  filter(set==\"train\") %>%\n  select(PassengerId, Survived) %>%\n  group_by(Survived) %>%\n  summarise(n = n()) %>%\n  mutate(freq = n / sum(n))\n\ncrude_survrate <- crude_summary$freq[crude_summary$Survived==\"Yes\"]\nkable(crude_summary, caption=\"2x2 Contingency Table on Survival.\", format=\"markdown\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"c36ad2a802afa709da84105d9764f2bfca6d015a"},"cell_type":"code","source":"g1_pclass <- ggplot(full %>% filter(set==\"train\"), aes(Pclass, fill=Survived)) +\n  geom_bar(position = \"fill\") +\n  scale_fill_brewer(palette=\"Set1\") +\n  scale_y_continuous(labels=percent) +\n  ylab(\"Survival Rate\") +\n  geom_hline(yintercept=crude_survrate, col=\"white\", lty=2, size=2) +\n  ggtitle(\"Survival Rate by Class\") + \n  theme_minimal()\n\ng2_sex <- ggplot(full %>% filter(set==\"train\"), aes(Sex, fill=Survived)) +\n  geom_bar(position = \"fill\") +\n  scale_fill_brewer(palette=\"Set1\") +\n  scale_y_continuous(labels=percent) +\n  ylab(\"Survival Rate\") +\n  geom_hline(yintercept=crude_survrate, col=\"white\", lty=2, size=2) +\n  ggtitle(\"Survival Rate by Sex\") + \n  theme_minimal()\n\ntbl_age <- full %>%\n  filter(set==\"train\") %>%\n  select(Age, Survived) %>%\n  group_by(Survived) %>%\n  summarise(mean.age = mean(Age, na.rm=TRUE))\n\ng3_age <- ggplot(full %>% filter(set==\"train\"), aes(Age, fill=Survived)) +\n  geom_histogram(aes(y=..density..), alpha=0.5) +\n  geom_density(alpha=.2, aes(colour=Survived)) +\n  geom_vline(data=tbl_age, aes(xintercept=mean.age, colour=Survived), lty=2, size=1) +\n  scale_fill_brewer(palette=\"Set1\") +\n  scale_colour_brewer(palette=\"Set1\") +\n  scale_y_continuous(labels=percent) +\n  ylab(\"Density\") +\n  ggtitle(\"Survival Rate by Age\") + \n  theme_minimal()\n\ng4_agegroup <- ggplot(full %>% filter(set==\"train\" & !is.na(Age)), aes(`Age Group`, fill=Survived)) +\n  geom_bar(position = \"fill\") +\n  scale_fill_brewer(palette=\"Set1\") +\n  scale_y_continuous(labels=percent) +\n  ylab(\"Survival Rate\") +\n  geom_hline(yintercept=crude_survrate, col=\"white\", lty=2, size=2) +\n  ggtitle(\"Survival Rate by Age Group\") + \n  theme_minimal()\n\ng5_sibsp <- ggplot(full %>% filter(set==\"train\"), aes(SibSp, fill=Survived)) +\n  geom_bar(position = \"fill\") +\n  scale_fill_brewer(palette=\"Set1\") +\n  scale_y_continuous(labels=percent) +\n  ylab(\"Survival Rate\") +\n  geom_hline(yintercept=crude_survrate, col=\"white\", lty=2, size=2) +\n  ggtitle(\"Survival Rate by SibSp\") + \n  theme_minimal()\n\ng6_parch <- ggplot(full %>% filter(set==\"train\"), aes(Parch, fill=Survived)) +\n  geom_bar(position = \"fill\") +\n  scale_fill_brewer(palette=\"Set1\") +\n  scale_y_continuous(labels=percent) +\n  ylab(\"Survival Rate\") +\n  geom_hline(yintercept=crude_survrate, col=\"white\", lty=2, size=2) +\n  ggtitle(\"Survival Rate by Parch\") + \n  theme_minimal()\n\ng7_embarked <- ggplot(full %>% filter(set==\"train\"), aes(Embarked, fill=Survived)) +\n  geom_bar(position = \"fill\") +\n  scale_fill_brewer(palette=\"Set1\") +\n  scale_y_continuous(labels=percent) +\n  ylab(\"Survival Rate\") +\n  geom_hline(yintercept=crude_survrate, col=\"white\", lty=2, size=2) +\n  ggtitle(\"Survival Rate by Embarked\") + \n  theme_minimal()\n\ng8_title <- ggplot(full %>% filter(set==\"train\") %>% na.omit, aes(title, fill=Survived)) +\n  geom_bar(position=\"fill\") +\n  scale_fill_brewer(palette=\"Set1\") +\n  scale_y_continuous(labels=percent) +\n  ylab(\"Survival Rate\") +\n  geom_hline(yintercept=crude_survrate, col=\"white\", lty=2, size=2) +\n  ggtitle(\"Survival Rate by Title\") + \n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\n\ng9_family <- ggplot(full %>% filter(set==\"train\") %>% na.omit, aes(`FamilySize`, fill=Survived)) +\n  geom_bar(position=\"fill\") +\n  scale_fill_brewer(palette=\"Set1\") +\n  scale_y_continuous(labels=percent) +\n  ylab(\"Survival Rate\") +\n  geom_hline(yintercept=crude_survrate, col=\"white\", lty=2, size=2) +\n  ggtitle(\"Survival Rate by Family Group\") + \n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"6a84abaebaa1f77565db448d03f4dc9d5a26fcec"},"cell_type":"code","source":"grid.arrange(g1_pclass, g2_sex)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"5882a16041a98a997060146bf87a2f3f90499a4f"},"cell_type":"code","source":"grid.arrange(g3_age , g4_agegroup)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"b8470479bc24d336549b9efccf86b33d61d93826"},"cell_type":"code","source":"grid.arrange(g5_sibsp  , g6_parch)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"65524921f12b5eaba8131deca0cd2e77753cdfef"},"cell_type":"code","source":"grid.arrange(g7_embarked   , g8_title, g9_family )","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"6c81224f793394d3e017b908bb5c7355ba45bae6"},"cell_type":"code","source":"tbl_corr <- full %>%\n  filter(set==\"train\") %>%\n  select(-PassengerId, -SibSp, -Parch) %>%\n  select_if(is.numeric) %>%\n  cor(use=\"complete.obs\") %>%\n  corrplot.mixed(tl.cex=0.85)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"3eaa5e63ca88aa8149399873c0cda5ab51ed34aa"},"cell_type":"code","source":"tbl_mosaic <- full %>%\n  filter(set==\"train\") %>%\n  select(Survived, Pclass, Sex, AgeGroup=`Age Group`, title, Embarked, `FamilySize`) %>%\n  mutate_all(as.factor)\n\nmosaic(~Pclass+Sex+Survived, data=tbl_mosaic, shade=TRUE, legend=TRUE)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"291dfff7f5e917a340215e2b5050ca9c9fad82e1"},"cell_type":"code","source":"library(alluvial)\n\ntbl_summary <- full %>%\n  filter(set==\"train\") %>%\n  group_by(Survived, Sex, Pclass, `Age Group`, title) %>%\n  summarise(N = n()) %>% \n  ungroup %>%\n  na.omit\n\nalluvial(tbl_summary[, c(1:4)],\n         freq=tbl_summary$N, border=NA,\n         col=ifelse(tbl_summary$Survived == \"Yes\", \"blue\", \"gray\"),\n         cex=0.65,\n         ordering = list(\n           order(tbl_summary$Survived, tbl_summary$Pclass==1),\n           order(tbl_summary$Sex, tbl_summary$Pclass==1),\n           NULL,\n           NULL))","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"8e46c15a994073a4e91b2f7f2bcaab21dc06122f"},"cell_type":"markdown","source":"## Titantic Mega Model - [0.84210] 커널 튜토리얼\n\n- 6 가지 모델이 1 가지 모델보다 뛰어날까요?\n- 타이탄 메가 모형은 Kaggle의 최고 6 개의 타이탄 모형의 앙상블이고 84.2 % 성능!! 먼저 우리는 이름만 모델을 사용하여 간단한 타이타닉으로 시작합니다. Ticket, Fare, Pclass를 조심스럽게 통합함으로써 점수를 83.3 % 인상 할 것입니다. \n\n- 모델은 모든 여성과 소년이 살고있는 가정의 모든 소년의 생존율을 예측합니다. 그리고 그것은 모든 여성과 소년들이 죽은 한 가족의 모든 여성들에 대해 사망할 것이라고 예측합니다. \n- 그것은 단지 22 가지 예언을 합니다. 시험 데이터 세트에 396 명의 승객이 남아 있습니다. 우리는 그 (것)들을 예언하기 위하여 Kaggle의 최고 타이탄 모형의 앙상블을 건설 할 것\n\n![Titanic Mega Model](http://playagricola.com/Kaggle/tree6.jpg)"},{"metadata":{"_uuid":"87adea7141ce3b909340513cb6287f6964a652ee"},"cell_type":"markdown","source":"## PART A: The Woman-Child-Group Model\n\n- 여기에 게시 된 Woman-Child-Group 모델에서 여성 - 아동 집단은 surname(칭호, 호칭)으로 형성되었습니다. 그러나 Surname는 항상 승객이 같은 가족에 속해 여행한다는 의미는 아닙니다. 승객 195와 1167을보십시오 :\n\n`PId Pclass              Name     Sex Age SibSp Parch   Ticket    Fare Cabin Embarked\n195   1     Brown, Mrs. James  female  44     0     0 PC 17610 27.7208    B4        C\n1067  2    Brown, Miss. Edith  female  15     0     2    29750 39.0000              S`  \n\n\n- 그들은 둘 다 Surname이 '브라운'이며 딸과 함께 여행하는 어머니인 것으로 보입니다. 그러나, 그들은 다른 Pclasses, 다른 티켓, 다른 요금, 다른 캐빈, 다른 착륙, 호환되지 않는 SibSp과 Parch 있습니다. 나는 이 두 승객이 관련이 없다고 생각한다. 이제 승객 59, 473 및 1142를 살펴보십시오.\n\n`PId Pclass                 Name    Sex   Age SibSp Parch     Ticket  Fare Cabin Embarked\n59      2 West, Miss. Constance  female  5.00     1     2 C.A. 34651 27.75              S\n473     2 West, Mrs. Edwy Arthur female 33.00     1     2 C.A. 34651 27.75              S \n1142    2    West, Miss. Barbara female  0.92     1     2 C.A. 34651 27.75              S`  \n\nThey all have the surname 'West' and appear to be a mother traveling with her two daughters. They have the same Pclass, same Ticket, same Fare, same Cabin, same Embarked, and compatible SibSp and Parch. I believe these three passengers are related.\n\n- 그들은 모두 'West'라는 Surname을 갖고 있으며 두 딸과 함께 여행하는 어머니 인 것으로 보입니다. 그들에는 동일한 Pclass, 동일한 표, 동일한 운임, 동일한 오두막, 동일한 Embarked 및 겸용성 SibSp 및 Parch가있다. 나는이 세 명의 승객이 관련이 있다고 믿는다.\n\n\n### A1. Engineer a precise GroupId for woman-child-groups\n\n- 가족을 정확하게 식별하는 GroupId를 작성합시다. Jack Roberts는 Ticket에는 커널의 Surnames와 동일한 그룹화 정보가 들어 있습니다. 티켓만 사용하거나 그룹을 형성하기 위해 Surname만 사용하면 실수로 이어집니다. \n- 따라서 각 승객에 대해 연결 그룹 ID = Surname + Pclass + 티켓 + 운임 + 승차권을 형성합시다. \n- 때로는 함께 여행하는 승객의 티켓이 마지막 자리에서 달라지므로 티켓의 마지막 자리도 제거합시다. 예를 들어, 웨스트 부인의 티켓을 'C.A. 34651 '~'C.A. 3465X '. (나는이 멋진 트릭을 Erik Bruin의 노트 4.2.4 절의 티켓 번호를 제거하기 위해 배웠다.) \n- 나는 의도적으로 SibSp와 Parch를 GroupId에 포함하지 않습니다. 왜냐하면 많은 오류가 있기 때문입니다 (아래 설명 참조). Cabin 데이터가 너무 많아서 Cabin을 포함하지 않습니다."},{"metadata":{"trusted":true,"_uuid":"d675046f9b9378e239a7f41a4456bd87e1d413cc"},"cell_type":"code","source":"data <- rbind(train,test)\ndata$Surname = substring( data$Name,0,regexpr(',',data$Name)-1)\ndata$GroupId = paste( data$Surname, data$Pclass, sub('.$','X',data$Ticket), data$Fare, data$Embarked, sep='-')\ndata[c(195,1067,59,473,1142),c('Name','GroupId')]","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"74d8b0d8fcbd9697c29febf9cdc07890150a3c11"},"cell_type":"markdown","source":"- 이 새로운 GroupId를 사용하면 West는 함께 여행했지만 Brown은 그렇지 않았음이 분명합니다\n\n ### A2. Identify Nannies and Relatives traveling in woman-child-groups\n \n -  Now look at the following passengers:\n\n`PId Pclass                      Name    Sex Age SibSp Parch   Ticket   Fare      Cabin Embarked\n312   1    Ryerson, Miss. Emily Borie female  18     2    2 PC 17608 262.375 B57 B59 B63 B66   C\n743   1  Ryerson, Miss. Susan Parker  female  21     2    2 PC 17608 262.375 B57 B59 B63 B66   C\n91    1  Ryerson, Mrs. Maria          female  48     1    3 PC 17608 262.375 B57 B59 B63 B66   C\n951   1   Chaudanson, Miss. Victorine female  36     0    0 PC 17608 262.375             B61   C\n956   1   Ryerson, Master. John Borie   male  13     2    2 PC 17608 262.375 B57 B59 B63 B66   C\n1034  1    Ryerson, Mr. Arthur Larned   male  61     1    3 PC 17608 262.375 B57 B59 B63 B66   C`\n\n- 이것은 Ryerson 가족입니다. 성인 2 명과 어린이 3 명이 있습니다. 그들은 티켓 = 'PC 17608'에서 Cabin B57, B59, B63 및 B66에 머물렀다. \n- Pclass = 1에서 Embarked = C. Chaudanson Miss도 Ticket = 'PC 17608'을 구입하고 그들 옆의 캐빈 인 Cabin = B61에 머물렀다. \n- 나는 Chaudanson Miss가 Ryerson 가족과 함께 여행했고 유모 또는 친척 중 하나라고 생각합니다. 우리는 보모와 친척을 우리 여성 - 자녀 그룹에 추가하고 싶습니다. 왜냐하면 그 데이터는 그들이 여행 한 여성과 자녀들과 함께 살았거나 사망 한 것을 보여주기 때문입니다."},{"metadata":{"trusted":true,"_uuid":"50c5dccbac8641dafd10ec87ab0d7a9b648a8ea5"},"cell_type":"code","source":"# engineer titles\ndata$Title <- 'man'\ndata$Title[data$Sex=='female'] <- 'woman'\ndata$Title[grep('Master',data$Name)] <- 'boy'\n\n\n# color variable is used in plots below\ndata$Color <- data$Survived\n\n\n# engineer \"woman-child-groups\"\ndata$GroupId[data$Title=='man'] <- 'noGroup'\ndata$GroupFreq <- ave(1:1309,data$GroupId,FUN=length)\ndata$GroupId[data$GroupFreq<=1] <- 'noGroup'\ndata$TicketId = paste( data$Pclass,sub('.$','X',data$Ticket),data$Fare,data$Embarked,sep='-')\ncount = 0\n\n\n# add nannies and relatives to groups\nfor (i in which(data$Title!='man' & data$GroupId=='noGroup')){\n    data$GroupId[i] = data$GroupId[data$TicketId==data$TicketId[i]][1]\n    if (data$GroupId[i]!='noGroup') {\n        # color variable is used in plots below\n        if (is.na(data$Survived[i])) data$Color[i] = 5\n        else if (data$Survived[i] == 0) data$Color[i] = -1\n        else if (data$Survived[i] == 1) data$Color[i] = 2\n        count = count + 1\n    }\n}\ncat(sprintf('우리는 %d 명의 보모/친척을 찾아 그룹에 추가했습니다.\\n',count))","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"57c2f15d0dae2d9eac8c045818987592a7dd00c6"},"cell_type":"markdown","source":"### A3. Classify unknown woman-child-groups\n"},{"metadata":{"_uuid":"d97c10b1ee641419cb80b3c98a15b1b06523fada"},"cell_type":"markdown","source":""},{"metadata":{"trusted":true,"_uuid":"b3d29e62b1d522c230f30a47f0d5943b47fed74e"},"cell_type":"code","source":"data$GroupName = substring( data$GroupId,0,regexpr('-',data$GroupId)-1)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"b2592076beae4035be4ec58fe89b1dbe1522db91"},"cell_type":"code","source":"table(data$GroupName)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"01dc5ad720f8b1d9708081ff974ab1f38f412997"},"cell_type":"code","source":"data$Color[is.na(data$Color) & data$Title=='woman'] <- 3\ndata$Color[is.na(data$Color) & data$Title=='boy'] <- 4\nx = data$GroupId[data$GroupId!='noGroup']; x = unique(x); x=x[order(x)]\nplotData <- list(); g <- list()\n\nfor (i in 1:3) plotData[[i]] <- data[data$GroupId %in% x[(27*(i-1))+1:27],]\nfor (i in 1:3) g[[i]] = ggplot(data=plotData[[i]], aes(x=0,y=factor(GroupName))) +\n    geom_dotplot(dotsize=0.9,binwidth=1,binaxis='y',method=\"histodot\",stackgroups=T,\n        aes(fill=factor(Color),color=Title )) +\n    scale_color_manual(values=c('gray70','blue','gray70'),limits=c('man','boy','woman')) +\n    scale_fill_manual(values=c('#BB0000','#FF0000','#009900','#00EE00','gray70','gray70','white'),\n        limits=c('0','-1','1','2','3','4','5')) +\n    scale_y_discrete(limits = rev(levels(factor(plotData[[i]]$GroupName)))) +\n        theme(axis.title.x=element_blank(), axis.title.y=element_blank(),\n        axis.text.x=element_blank(), axis.ticks.x=element_blank(),\n        legend.position='none')\ngrid.arrange(g[[1]],g[[2]],g[[3]],nrow=1,top='All 80 woman-child-groups in the test and training datasets combined (228 passengers).\nRed = deceased female or boy, Green = survived, White or Gray = unknown survival, \nWhite or LightGreen or LightRed = different surname same ticket, Blue outline = boy')","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"a86809b9380c851cda5fe8abe3c1aa398046af05"},"cell_type":"markdown","source":"- 테스트 및 훈련 데이터 세트의 모든 80 명의 여성 - 아동 그룹이 합쳐졌습니다 (228 명의 승객). 빨간색 = 사망 한 여성 또는 소년, 녹색 = 생존, 흰색 또는 회색 = 생존 알 수 없음, 흰색 또는 LightGreen 또는 LightRed = 다른 성 이름의 티켓, 파란색 외곽선 = 소년\n\n- 첫 번째로 80 명의 여성 - 아동 집단 모두가 살았거나 모두 사망했는지 (우리가 알고있는 생존 정보를 기반으로) 주목합니다. 그것은 여성 - 아동 집단 모델의 숨은 비밀입니다. \n- 알 수 없는 회색 또는 흰색 원을 앞의 점의 색과 같게 설정하여 예측해야 한다고 합니다. \n- 예를 들어, Abbott는 살아있는 한 여성이 하나의 알려지지 않은 소년과 함께 여행하는 것을 보여줍니다. 미지의 소년 승객 1284 Master Eugene Abbott가 살아 남았음을 예측해야합니다. \n\n- 그룹 전체가 알려지지 않은 네 개의 가족이 있습니다. 이 가족은 Gibson, Klasen, Peacock, van Billiard입니다. 우리는 그들에 대한 예언을 해야합니다. 그래서 어느 여성 - 자녀 집단이 살고 있는지를 탐구합시다.\n"},{"metadata":{"trusted":true,"_uuid":"5ef66a9e98d2ab193b01f9c8a1713b3f760d83d7"},"cell_type":"code","source":"data$Survived <- factor(data$Survived)\ndata$CabinLetter <- substring(data$Cabin,0,1)\ng1 = ggplot(data=data[data$GroupId!='noGroup' & !is.na(data$Survived),]) +\n    geom_bar(stat='count',aes(x=Pclass,fill=Survived))\ng2 = ggplot(data=data[data$GroupId!='noGroup' & !is.na(data$Survived) & !is.na(data$Age),]) +\n    geom_histogram(bins=20,aes(x=Age,fill=Survived))\ng3 = ggplot(data=data[data$GroupId!='noGroup' & !is.na(data$Survived),]) +\n    geom_bar(stat='count',aes(x=Embarked,fill=Survived))\ng4 = ggplot(data=data[data$GroupId!='noGroup' & !is.na(data$Survived),]) +\n    geom_bar(stat='count',aes(x=CabinLetter,fill=Survived))\ngrid.arrange(g1,g2,g3,g4,nrow=2,top='Analysis of training set\\'s 156 Woman-Child-Group passengers')","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"97d32fc8f739f8b84f824c31dcfd6be08615e663"},"cell_type":"markdown","source":"- 분석에서 우리는 Pclass = 1 또는 2로 여행하는 여성 - 아동 집단이 대부분 생존하고 Pclass = 3에있는 여성 - 아동 집단이 대부분 사망 한 것을 알 수있다. \n- Gibsons는 Pclass = 1, Embarked = C 및 Cabin이 없었으므로 Gibsons가 살아남은 것을 예측해야합니다.\n- Klasen 's, Peacock 's, van billiards는 Pclass = 3, Embarked = S, Cabin은 없었습니다. 그러므로 우리는 이 세 가정이 소멸 될 것이라고 예측해야 합니다."},{"metadata":{"_uuid":"897e18c7c2bd959889d34fd6e281710fddd7f9f1"},"cell_type":"markdown","source":"### A4. Cross Validation\n\n- 이름 만 사용할 때이 모델은 훈련 데이터 세트에서 83.6 %의 유효성을 확인합니다. (1) 정확한 GroupId 사용, (2) 유모 및 친척 포함, (3) 알 수없는 그룹 분류로 모델의 정확성이 향상되는지 봅시다.\n\n[Titanic using Name only - 0.81818](https://www.kaggle.com/cdeotte/titanic-using-name-only-0-81818)"},{"metadata":{"trusted":true,"_uuid":"65d4298e5ecb24440feaeddfd8f65214754a02ca"},"cell_type":"code","source":"# engineer titles on training set\ntrain$Title <- 'man'\ntrain$Title[train$Sex=='female'] <- 'woman'\ntrain$Title[grep('Master',train$Name)] <- 'boy'\n\n\n# Perform 25 trials of 10-fold cross validation\ntrials = 25; sum = 0\n\nfor (j in 1:trials){\nx = sample(1:890); s = 0\nfor (i in 0:9){\n    # engineer \"woman-child-groups\"\n    train$Surname <- substring(train$Name,0,regexpr(\",\",train$Name)-1)\n    train$GroupId = paste( train$Surname, train$Pclass,sub('.$','X',train$Ticket),train$Fare,train$Embarked,sep='-')\n    train$GroupId[train$Title=='man'] <- 'noGroup'\n    train$GroupFreq <- ave(1:891,train$GroupId,FUN=length)\n    train$GroupId[train$GroupFreq<=1] <- 'noGroup'\n    # add nannies and relatives to groups.\n    train$TicketId = paste( train$Pclass,sub('.$','X',train$Ticket),train$Fare,train$Embarked,sep='-')\n    for (k in which(train$Title!='man' & train$GroupId=='noGroup'))\n        train$GroupId[k] = train$GroupId[train$TicketId==train$TicketId[k] & train$PassengerId != train$PassengerId[k]][1]\n    train$GroupId[is.na(train$GroupId)] <- 'noGroup'\n    train$GroupFreq <- ave(1:891,train$GroupId,FUN=length)\n    # calculate training subset's group survival rate\n    train$GroupSurvival <- NA\n    train$GroupSurvival[-x[1:89+i*89]] <- ave(train$Survived[-x[1:89+i*89]],train$GroupId[-x[1:89+i*89]])\n    # calculate testing subset's group survival rate from training set's rate\n    for (k in x[1:89+i*89]){ \n        train$GroupSurvival[k] <- train$GroupSurvival[which(!is.na(train$GroupSurvival) & train$GroupId==train$GroupId[k])[1]]\n        if (is.na(train$GroupSurvival[k])) train$GroupSurvival[k] <- ifelse(train$Pclass[k]==3,0,1)\n    }\n    # apply gender model plus WCG\n    train$predict <- 0\n    train$predict[train$Title=='woman'] <- 1\n    train$predict[train$Title=='boy' & train$GroupSurvival==1] <- 1\n    train$predict[train$Title=='woman' & train$GroupSurvival==0] <- 0\n    c = sum(abs(train$predict[x[1:89+i*89]] - train$Survived[x[1:89+i*89]]))\n    s = s + c\n}\n#cat( sprintf(\"Trial %d has 10-fold CV accuracy = %f\\n\",j,1-s/890))\nsum = sum + 1-s/890\n}\ncat(sprintf(\"Average 10-fold CV accuracy from %d trials = %f\\n\",trials,sum/trials))","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"d004f0346a6e35d603fccff8b0a1e2e58bc10dc5"},"cell_type":"markdown","source":"- 우리의 정확도는 0.8 % 증가하여 84.4 %로 나타났습니다. 우리의 변화가 도움이 된 것 같습니다. 테스트 데이터 세트에 대한 예측을하고 Kaggle에 제출하십시오."},{"metadata":{"_uuid":"a17bd53d48d5d414eb12b940681e4be8e02aee3c"},"cell_type":"markdown","source":"### A5. Make Predictions\n\n- 테스트 데이터 세트에서 여성 - 아동 그룹의 일부인 72 명의 승객이 있습니다. 두 가지 예측 규칙을 적용 해 보겠습니다.\n- unknown passenger's woman-child-group이 모두 살거나 모두 사망 한 경우 (훈련 데이터 세트에 표시된대로), 그들이 동일하게 수행 한 것으로 예측하십시오.\n- 알 수없는 승객의 woman-child-group에 훈련 데이터 세트에 구성원이 없으면 Pclass = 3 die, Pclass = 1 또는 2 Pclass를 사용하여 생존할 거라고 예측하십시오."},{"metadata":{"trusted":true,"_uuid":"9e32eb9ea8d593778d0a288ad7ad50f6afd15023"},"cell_type":"code","source":"data$GroupSurvival <- NA\ndata$Survived <- as.numeric(as.character(data$Survived))\ndata$GroupSurvival[1:891] <- ave(data$Survived[1:891],data$GroupId[1:891])\nfor (i in 892:1309) data$GroupSurvival[i] <- data$GroupSurvival[which(data$GroupId==data$GroupId[i])[1]]\ndata$GroupSurvival[is.na(data$GroupSurvival) & data$Pclass==3] <- 0\ndata$GroupSurvival[is.na(data$GroupSurvival) & data$Pclass!=3] <- 1\ndata$Predict <- 0\ndata$Predict[data$Sex=='female'] <- 1\ndata$Predict[data$Title=='woman' & data$GroupSurvival==0] <- 0\ndata$Predict[data$Title=='boy' & data$GroupSurvival==1] <- 1","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"ea13cc5ec35c494dd8fc5f8d404606d7c439d41b"},"cell_type":"code","source":"cat('The following 8 males are predicted to live\\n')\ndata[data$Sex=='male' & data$Predict==1 & data$PassengerId>891,c('Name','Title')]\ncat('The following 14 females are predicted to die\\n')\ndata[data$Sex=='female' & data$Predict==0 & data$PassengerId>891,c('Name','Title')]\ncat('The remaining 258 males are predicted to die\\n')\ncat('and the remaining 138 females are predicted to live\\n')","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"e82007bd3788602fa8c350f0dda2b3e79307819b"},"cell_type":"code","source":"submit <- data.frame(PassengerId = 892:1309, Survived = data$Predict[892:1309])\nwrite.csv(submit,'genderSurnameModel2.csv',row.names=F)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"79426420947ab58a3a5d2947b8ee665a432c062a"},"cell_type":"markdown","source":" ![result](http://playagricola.com/Kaggle/surnameModel2.png)\n Woohoo!! Our simple woman-child-group model scores 83.3%, incredible!"},{"metadata":{"_uuid":"cd97eaa0a3f27649622db315a46f2b687d3be4af"},"cell_type":"markdown","source":"### A6. Why didn't we use SibSp, Parch, Cabin in GroupId?\n\n- 왜 우리는 SibSp, Parch 및 Cabin을 사용하여 우리 여성 - 아동 집단을 확인하지 않았습니까? 여성 - 자녀 집단이 속한 80 개 가정에서 SibSp와 Parch는 27 개의 오류가 있습니다. 다음은 오류의 예입니다.\n\n`PId Pclass               Name    Sex Age SibSp Parch     Ticket  Fare Embarked\n162     2     Watt, Mrs. James female  40     0     0 C.A. 33595 15.75        S\n1012    2   Watt, Miss. Bertha female  12     0     0 C.A. 33595 15.75        S`  \n\n- 다음은 딸과 함께 여행하는 어머니입니다. 그들은 동일한 성, 동일한 Pclass, 동일한 표, 동일한 운임, 동일한 승선이 있습니다. 그러나 SibSp와 Parch는 모두 0과 같습니다. Cabin 정보의 77.5 %가 누락 되었기 때문에 우리 그룹에서 Cabin을 사용하지 않았습니다."},{"metadata":{"_uuid":"33b164e59b30446d2841ccca1a826fe4059e5ada"},"cell_type":"markdown","source":"## Titanic WCG+XGBoost Tutorial\n\n[Titanic WCG+XGBoost - 0.84688](https://www.kaggle.com/cdeotte/titanic-wcg-xgboost-0-84688)\n\n- 타이타닉 테스트 데이터 세트에는 성인 남성이 245 명이 있습니다. Kaggle의 모든 상위 모델을 검토하면 모든 성인 남성이 사망 할 것이라고 모든 사람이 예측합니다. \n\n- 살았던 성인 남성 한 명 이상을 찾을 수 있습니까? 성인 남성의 생존율을 정확하게 예측할 수 있다면 가장 정확한 타이타닉 모델을 구할 수 있습니다!\n\n![tree12](http://playagricola.com/Kaggle/tree12.jpg)  \n  \n\n### Explore adult males survival with XGBoost\n\n- 먼저 Titanic 데이터 세트를 로드하고 Age and Fare가 누락된 것을 확인할 수 있습니다.\n- 다음으로 x1 = Fare / (Ticket Frequency * 10) 및 x2 = Parch + SibSp + 1 + (Age / 70)의 두 가지 새로운 변수를 설계합니다. 형상 공간을 2 차원으로 축소하면 모든 것을 시각화 할 수 있습니다.\n  \n[1]:https://www.kaggle.com/cdeotte/titanic-wcg-xgboost-0-84688"},{"metadata":{"trusted":true,"_uuid":"735b006ad1c995865797083200301025a7efcb01"},"cell_type":"code","source":"train <- read.csv('../input/titanic/train.csv',stringsAsFactors=F)\ntest <- read.csv('../input/titanic/test.csv',stringsAsFactors=F)\ntest$Survived <- NA; data <- rbind(train,test)\n# engineer person type\ndata$Title <- 'man'\ndata$Title[grep('Master',data$Name)] <- 'boy'\ndata$Title[data$Sex=='female'] <- 'woman'","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"6a1afbd4b4bffae8767fe01c57be4a1dbd60bed4"},"cell_type":"code","source":"fit <- rpart(Age ~ Title + Pclass + SibSp + Parch,data=data)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"1b3981c92813e76c74b45477a682fe85dee24e85"},"cell_type":"code","source":"fit","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"2fc4b627d7c2691d274e04f3521d7cae80ac51b1"},"cell_type":"code","source":"data$Age[is.na(data$Age)] <- predict(fit,newdata=data[is.na(data$Age),])","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"4726a460441a97d8e5ee99d367dc35a07c80eb93"},"cell_type":"code","source":"fit <- rpart(Fare ~ Title + Pclass + Embarked + Sex + Age,data=data)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"118236ffcd686078804db2fe927dfaeebb35dd7c"},"cell_type":"code","source":"fit","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"831cc392c0feab2009a8310e49260e4227439000"},"cell_type":"code","source":"data$Fare[is.na(data$Fare)] <- predict(fit,newdata=data[is.na(data$Fare),])","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"83184213599c9d11bcaf25ae8bb1ccda67ed9a30"},"cell_type":"code","source":"data <- data %>% as.tibble() %>%\n    mutate(TicketFreq  = ave(1:1309, Ticket,FUN=length),\n           FareAdj = Fare / TicketFreq,\n           FamilySize = SibSp + Parch + 1\n          )           ","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"a46d95bd9107cd2c9576ca39cf7b326c25d1020f"},"cell_type":"code","source":"data2 <- data[data$PassengerId<=891 & data$Title=='man',]","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"d2b7046b25a62f0a28f732eeb92272d86bd9fcfc"},"cell_type":"code","source":"data3 <- data.frame(\n    y = data2$Survived,\n    x1 = data2$Fare / (data2$TicketFreq * 10),\n    x2 = (data2$SibSp + data2$Parch + 1) + (data2$Age / 70),\n    Pclass = data2$Pclass)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"7c23222b6ea3dcd92165b4520d69db0ad707a9d1"},"cell_type":"code","source":"g1 = ggplot(data[data$FareAdj>0 & data$FareAdj<40,]) + \n    geom_density(aes(x=FareAdj,fill=factor(Pclass)),alpha=0.9,show.legend=F) +\n    labs(fill='Pclass') + geom_vline(xintercept=c(10,20),linetype='dotted') +\n    xlim(0,40) + labs(title='All Passengers',x='x1 = Fare / Ticket Frequency')\n\ng2 = ggplot(data[data$Fare>0 & data$Fare<40 ,]) +\n    geom_density(aes(x=Fare,fill=factor(Pclass)),alpha=0.9) +\n    xlim(0,40) + labs(title='All Passengers',fill='Pclass',y='')\n\ng3 = ggplot(data[!is.na(data$Survived) & data$Title=='man' & data$Pclass==1 & data$FamilySize<4,]) + \n    geom_density(aes(x=FamilySize+Age/70,fill=factor(Survived)),alpha=0.9,bw=0.04) +\n    labs(fill='Survived') +\n    annotate('text',x=1.4,y=2.4,label='Age 30\\nFS=1') +\n    annotate('text',x=2.4,y=2.4,label='Age 30\\nFS=2') +\n    geom_vline(xintercept=c(1.43,2.43),linetype='dotted') +\n    xlim(1,4) + labs(title='Adult Males Pclass=1',x='x2 = FamilySize + Age/70')\n\ngrid.arrange(g3,g1,g2,layout_matrix = rbind(c(1, 1), c(2, 3)))","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"dc15771e73f98220774a5d29adc5604f251a5777"},"cell_type":"markdown","source":"- FamilySize + Age / 70을 작성하면 1 차원에서 SibSp(같이 탑승한 형제 / 배우자 숫자), Parch (같이 탑승한 부모, 자녀의 숫자) 및 Age를 볼 수 있습니다. \n- 20 세에서 36 세 사이의 Pclass = 1에서 FamilySize <= 2 인 성인 남성이 생존 확률이 50 % 이상임을 보여줍니다. (정확하게, 훈련 세트에서 56 % = 18 / 32 생존). 또한 FamilySize = 2 인 40 대 남성의 경우 생존 확률이 63 % (= 5/8)입니다. '\n - Fare를 TicketFrequency로 나눕니다. 실제 가격이 지불 되었기 때문입니다. ( 11 명의 세이지 가족은 그들의 11 번째 3 종 티켓 각각에 대해 69.55 달러를 내지 않았다. )\n\n- 그들은 $ 6.32 = 69.55 / 11.를 지불했을 것입니다. \n- 마지막으로, 'x1'을 10으로 나누어 스케일이 'x2'의 스케일과 일치하도록 하여 특정 기계학습 알고리즘을 돕습니다. XGBoost를 변수 쌍 (x1, x2)에 적용하고 어떤 패턴을 발견하는지 살펴 보겠습니다."},{"metadata":{"_kg_hide-input":true,"trusted":true,"_uuid":"0e98a9609bd97bcd7b0c856f4ddf1274a2192526"},"cell_type":"code","source":"# classify males with xgboost\nset.seed(2310)\n\nx1s <- seq(0, 5, length.out = 100)\nx2s <- seq(1, 3, length.out = 100)\ng <- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\nparam <- list(objective   = \"binary:logistic\",\n            eval_metric = \"error\",\n            max_depth   = 5,\n            eta         = 0.1,\n            gammma      = 0.1,\n            colsample_bytree = 1,\n            min_child_weight = 1)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"550fcb5dc5994f8169b74bb335921b4f4a431b0e"},"cell_type":"code","source":"param","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"ebe2fde6d9ea0251cf8e9bc75eb08da344c7f015"},"cell_type":"code","source":"dim(data.matrix(data3[,c('x1','x2')]))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"d52baa50024986994b8075f5bf23dd91718df135"},"cell_type":"code","source":"length(data3$y)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"70ea787f5cd0c1e9fea674cdcb2af88598a6e8b4"},"cell_type":"code","source":"cat('XGBoosting begun...\\n')\nxgb <- xgboost(params  = param,\n            data    = data.matrix(data3[,c('x1','x2')]),\n            label   = as.numeric(as.factor(data3$y)) - 1 , \n            nrounds = 500,\n            print_every_n = 100,\n            verbose = 1)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"449e850b5993f348b3233cbd5451ed26c09984a9"},"cell_type":"code","source":"p <- predict(xgb,newdata=data.matrix(g[,c('x1','x2')]))\ng$y <- ifelse(p>0.5,1,0)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"eae9b02512c62df32fcb008fe59023e570938d92"},"cell_type":"code","source":"head(g)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"049a124e331d654c9283abd227f2df4f6ee8cce9"},"cell_type":"code","source":"ggplot(data=data3[data3$x1<5 & data3$x2<3,]) +\n    xlim(0,5) + ylim(1,3) +\n    geom_tile(data=g,aes(x1,x2,fill=factor(y))) +\n    geom_density_2d(aes(x1,x2,color=factor(y))) +\n    geom_point(size=2,aes(x1,x2,color=factor(y),shape=factor(Pclass))) +\n    scale_color_manual(values=c('#AA0000','#00AA00'),\n        limits=c('0','1'),labels=c('0','1')) +\n    scale_fill_manual(values=c('#FF9999','#99FF99'),\n        limits=c('0','1'),labels=c('0','1')) +\n    labs(x='Fare / (10 x TicketFrequency)',y='FamilySize + (Age / 70)',shape='Pclass',fill='Classify',\n        title='XGBoost learns the training set\\'s\n        537 adult males. Green is P(live)>0.5',color='Survived') +\n    geom_vline(xintercept=2.8, linetype='dotted') +\n    geom_hline(yintercept=c(1.43,2.43), linetype='dotted') +\n    annotate('text',x=2.95,y=2.9,label='Fare = $28') +\n    annotate('text',x=4.7,y=2.35,label='Age = 30') +\n    annotate('text',x=4.7,y=1.35,label='Age = 30')","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"bd3684494c36610f3938364789630f447bc2e5aa"},"cell_type":"markdown","source":" - XGBoost에서 훈련 데이터 세트의 성인 남성 중 생존 패턴을 찾은 것 같습니다! \n - 도표에서 우리는 생존 가능성이 가장 높은 성인 남성이 Pclass = 1, FareAdj = 28 달러, SibSp + Parch <= 1, Age = 30이라는 것을 알 수 있습니다. 음영은 XGBoost의 분류 결정이 무엇인지 나타냅니다. 녹색 영역은 P (라이브)> 0.5를 예측하는 XGBoost에 해당합니다."},{"metadata":{"_kg_hide-input":true,"trusted":true,"_uuid":"3ee8eb7bae87a79ae0a2e5c4406682d8c45c987b"},"cell_type":"code","source":"set.seed(300)\ns = sample(1:537,100)\ns2 = (1:537)[-s]\nxgb <- xgboost(params  = param,\n            data    = data.matrix(data3[s2,c('x1','x2')]),\n            label   = as.numeric(as.factor(data3$y[s2])) - 1 ,  \n            nrounds = 500,\n            print_every_n = 100,\n            silent = 1,\n            verbose = 0)\n\np <- predict(xgb,newdata=data.matrix(data3[s,c('x1','x2')]))\ndata3$y2 <- NA\nroc = data.frame(TN=rep(0,102),FP=rep(0,102),FN=rep(0,102)\n    ,TP=rep(0,102),FPR=rep(0,102),TPR=rep(0,102))\nrownames(roc) <- seq(0,1.01,0.01)\nfor (i in 1:102){\n    data3$y2[s] <- ifelse(p<(i-1)/100,0,1)\n    roc$TP[i] <- length(which(data3$y==1 & data3$y2==1))\n    roc$TN[i] <- length(which(data3$y==0 & data3$y2==0))\n    roc$FP[i] <- length(which(data3$y==0 & data3$y2==1))\n    roc$FN[i] <- length(which(data3$y==1 & data3$y2==0))\n    roc$FPR[i] <- roc$FP[i] / (roc$FP[i] + roc$TN[i])\n    roc$TPR[i] <- roc$TP[i] / (roc$TP[i] + roc$FN[i])\n}\ndiag <- data.frame(x=c(0,1),y=c(0,1))\nggplot(roc,aes(x=FPR,y=TPR)) + \n    geom_line() + labs(title='ROC curve where \"positive\" = male survives',\n        x='False positive rate',y='True positive rate') +\n    geom_point(data=roc[91,],aes(x=FPR,y=TPR),size=3,color='red') +\n    annotate('text',x=0.13,y=0.12,label='threshold p>=0.9',color='red') +\n    geom_point(data=roc[76,],aes(x=FPR,y=TPR),size=3,color='darkgreen') +\n    annotate('text',x=0.16,y=0.30,label='threshold p>=0.75',color='darkgreen') +\n    geom_point(data=roc[51,],aes(x=FPR,y=TPR),size=3,color='blue') +\n    annotate('text',x=0.20,y=0.5,label='threshold p>=0.5',color='blue') +\n    geom_line(data=diag,aes(x=x,y=y),linetype='dotted')\narea = 0\nfor(i in 1:101){\n    area = area + roc$TPR[i] * (roc$FPR[i]-roc$FPR[i+1])\n}\ncat(sprintf('Area under ROC = %f\\n',area))","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"3345019f7c301ae5ed7cfa7540310ecc524c69a3"},"cell_type":"markdown","source":"- ROC 아래의 AUC는 0.82> 0.50입니다. (100 회 시행중인 평균 AUC = 0.70) 즉, XGBoost가 생존 패턴을 발견했습니다.\n- ROC 플롯은 또한 XGBoost가 P (live)> 0.5라고 말할 때마다 생존 할 것으로 예측하면 많은 1종 오류를 만듭니다 (즉, 성인 남성이 생존하지 않을 때 생존하는 것으로 잘못 예측합니다). 정확도를 극대화하기 위해 임계 값을 신중하게 선택해야 하므로 그리드 검색을 사용하여 0.50, 0.75, 0.90 및 0.92 중에서 최상의 임계 값을 찾습니다.\n\n\n## Grid search and cross validate\n- 그리드 검색을 사용하여 XGBoost에 대한 최적의 매개 변수가 treeDepth = 5, p> = 0.90임을 알 수 있습니다. \n- 그리드 검색을 수행하려면 아래 코드에서 for 루프의 주석 처리를 제거하고 검색 할 하이퍼 매개 변수를 추가하십시오.이 노트에서는 그리드 검색을 수행하지 않습니다. . 이제 XGBoost가 CV = 78.6 % 인 성별 모델보다 더 정확한지 확인하기 위해 교차 유효성 검사를 수행해 봅시다."},{"metadata":{"_kg_hide-input":true,"trusted":true,"_uuid":"d8c6c46d68f88e47351ad0b64c2bdb8686625ba1"},"cell_type":"code","source":"#accuracy = matrix(nrow=4,ncol=4)\n#rownames(accuracy) <- c('d=3','d=4','d=5','d=6')\n#colnames(accuracy) <- c('0.50','0.75','0.90','0.92')\n#for (j in 1:4)\n#for (k in 1:4){\nset.seed(2)\ntrials=100; sum=0\nfor (i in 1:trials){\n    s = sample(1:891,800)\n    s2 = (1:891)[-s]\n    dataB <- data[data$PassengerId %in% s & data$Title=='man',]\n    dataC <- data[data$PassengerId %in% s2 & data$Title=='man',]\n    data$Predict <- 0\n    data$Predict[data$Sex=='female'] <- 1\n    dataTrain <- data.frame(y=as.numeric(as.factor(dataB$Survived)) - 1,x1=dataB$FareAdj/10,x2=dataB$FamilySize+dataB$Age/70)\n    dataTest <- data.frame(y=as.numeric(as.factor(dataC$Survived)) - 1,x1=dataC$FareAdj/10\n        ,x2=dataC$FamilySize+dataC$Age/70,PassengerId=dataC$PassengerId)\n    param <- list(objective   = \"binary:logistic\",\n              eval_metric = \"error\",\n              max_depth   = 5,\n              eta         = 0.1,\n              gammma      = 0.1,\n              colsample_bytree = 1,\n              min_child_weight = 1)\n    xgb <- xgboost(params  = param,\n              data    = data.matrix(dataTrain[,c('x1','x2')]),\n              label   = dataTrain$y, \n              nrounds = 500,\n              silent = 1,\n              print_every_n = 100,\n              verbose = 0)\n    p <- predict(xgb,newdata=data.matrix(dataTest[,c('x1','x2')]))\n    dataTest$p <- ifelse(p>=0.90,1,0)\n    data$Predict[dataTest$PassengerId] <- dataTest$p \n    sm = sum(abs(as.integer(data$Predict[s2]) - as.integer(data$Survived[s2])))\n    cv = 1 - sm/length(s2)\n    #if (i %% 25==0) \n    #cat(sprintf('Trial %d has CV = %f\\n',i,cv))\n    sum = sum + cv\n}\ncat(sprintf('Average CV of %d trials = %f\\n',trials,sum/trials))\n#accuracy[j,k] <- sum/trials\n#}\n#accuracy","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"699fa387f05fb88dc228bc048f4c40b0450202b3"},"cell_type":"markdown","source":"- CV 정확도는 79.0 %입니다. (위에 표시된 결과는 k 배 CV의 무작위 특성으로 인해 달라질 수 있지만 오프라인에서는 10,000 회의 평가에서 79.0 %를 확인했습니다.) \n- 성별 모델의 CV 정확도는 78.6 %이므로 약간 개선되었습니다. 다행히도, 이것은 우리가 테스트 데이터 세트에서 적어도 살아남은 성인 남성 1 명을 발견 할 수있게 해줍니다!\n\n\n## Submission to Kaggle"},{"metadata":{"_kg_hide-input":true,"trusted":true,"scrolled":false,"_uuid":"d5aa5fbf16ce8dfb18aa4a57af50a41d375ca373"},"cell_type":"code","source":"dataB <- data[data$PassengerId %in% 1:891 & data$Title=='man',]\ndataC <- data[data$PassengerId %in% 892:1309 & data$Title=='man',]\ndata$Predict <- 0\ndata$Predict[data$Sex=='female'] <- 1\ndataTrain <- data.frame(y=as.numeric(as.factor(dataB$Survived)) - 1,x1=dataB$FareAdj/10,x2=dataB$FamilySize+dataB$Age/70)\ndataTest <- data.frame(y=as.numeric(as.factor(dataC$Survived)) - 1,x1=dataC$FareAdj/10,Pclass=dataC$Pclass\n    ,x2=dataC$FamilySize+dataC$Age/70,PassengerId=dataC$PassengerId)\n\nparam <- list(objective   = \"binary:logistic\",\n              eval_metric = \"error\",\n              max_depth   = 5,\n              eta         = 0.1,\n              gammma      = 0.1,\n              colsample_bytree = 1,\n              min_child_weight = 1)\n\nxgb <- xgboost(params  = param,\n              data    = data.matrix(dataTrain[,c('x1','x2')]),\n              label   = dataTrain$y, \n              nrounds = 500,\n              silent = 1,\n              print_every_n = 100,\n              verbose = 0)\n\np <- predict(xgb,newdata=data.matrix(dataTest[,c('x1','x2')]))\ndataTest$p <- ifelse(p>=0.90,1,0)\ndata$Predict[dataTest$PassengerId] <- dataTest$p \nmaleLive = which(data$Title=='man' & data$Predict==1)\ncat(sprintf('The following %d adult males are predicted to live\\n',length(maleLive)))\ndata[maleLive,c('PassengerId','Pclass','Name','Age','SibSp','Parch','FareAdj')]","execution_count":null,"outputs":[]},{"metadata":{"_kg_hide-input":true,"trusted":true,"_uuid":"972c374198100eaab09cab8ac1289f5cfed6714f"},"cell_type":"code","source":"x1s <- seq(2, 5, length.out = 100)\nx2s <- seq(1, 3, length.out = 100)\ng <- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\np <- predict(xgb,newdata=data.matrix(g[,c('x1','x2')]))\ng$y <- ifelse(p>=0.90,1,0)\ng1 <- ggplot(data=dataTest[dataTest$x1>2 & dataTest$x1<5 & dataTest$x2>1 & dataTest$x2<3,]) +\n    xlim(2,5) + ylim(1,3) +\n    geom_tile(data=g,aes(x1,x2,fill=factor(y))) +\n    geom_point(size=2,aes(x1,x2,color=factor(p),shape=factor(Pclass))) +\n    scale_color_manual(values=c('#666666','#0000FF'),\n        limits=c('0','1'),labels=c('0','1')) +\n    scale_fill_manual(values=c('#FF9999','#99FF99'),\n        limits=c('0','1'),labels=c('0','1')) +\n    labs(x='Fare / (10 x TicketFrequency)',y='FamilySize + (Age / 70)',shape='Pclass',fill='Classifier',\n        title='XGBoost classifies the test set.\n        It predicts 4 adult males have P(live)>=0.9',color='Predict') +\n    geom_vline(xintercept=2.8, linetype='dotted') +\n    geom_hline(yintercept=c(1.43,2.43), linetype='dotted') +\n    annotate('text',x=2.95,y=2.9,label='Fare = $28') +\n    annotate('text',x=4.7,y=2.35,label='Age = 30') +\n    annotate('text',x=4.7,y=1.35,label='Age = 30')\n\nfor (i in which(dataTest$p==1)){\n    g1 <- g1 + annotate('text',x=dataTest$x1[i]-0.15,y=dataTest$x2[i],label=dataTest$PassengerId[i]\n        ,color='darkblue',size=4)\n}\ng1","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"d51253343dbdd0e4cf55c6789e4629869e389ebd"},"cell_type":"markdown","source":"나머지 예측에서는 다음 두 가지 간단한 규칙 (WCG model, woman-child-groups)을 사용합니다.\n\n* 모든 여성과 소년이 살고있는 가정의 모든 소년에 대한 생존율 예측.\n* 모든 여성과 소년이 사망하는 가정의 모든 여성에 대한 사망 예측."},{"metadata":{"_kg_hide-input":true,"trusted":true,"_uuid":"b52547199323effbc4ea8c844da7579d1f8854f0"},"cell_type":"code","source":"# engineer \"woman-child-groups\"\ndata$Surname = substring( data$Name,0,regexpr(',',data$Name)-1)\ndata$GroupId = paste( data$Surname, data$Pclass, sub('.$','X',data$Ticket), data$Fare, data$Embarked, sep='-')\ndata$GroupId[data$Title=='man'] <- 'noGroup'\n# Mrs Wilkes (Needs) is Mrs Hocking (Needs) sister\ndata$GroupId[893] <- data$GroupId[775]\ndata$GroupFreq <- ave(1:1309,data$GroupId,FUN=length)\ndata$GroupId[data$GroupFreq<=1] <- 'noGroup'\ncat(sprintf('We found %d woman-child-groups\\n',length(unique(data$GroupId))-1))\ndata$TicketId = paste( data$Pclass,sub('.$','X',data$Ticket),data$Fare,data$Embarked,sep='-')\n# add nannies and relatives to groups\nc = 0\nfor (i in which(data$Title!='man' & data$GroupId=='noGroup')){\n    data$GroupId[i] = data$GroupId[data$TicketId==data$TicketId[i]][1]\n    if (data$GroupId[i]!='noGroup') c = c + 1\n}\ncat(sprintf('We found %d nannies/relatives and added them to groups.\\n',c))\n# calculate group survival rates\ndata$GroupSurvival <- NA\ndata$Survived <- as.numeric(as.character(data$Survived))\ndata$GroupSurvival[1:891] <- ave(data$Survived[1:891],data$GroupId[1:891])\nfor (i in 892:1309) data$GroupSurvival[i] <- data$GroupSurvival[which(data$GroupId==data$GroupId[i])[1]]\n# classify unknown groups\ndata$GroupSurvival[is.na(data$GroupSurvival) & data$Pclass==3] <- 0\ndata$GroupSurvival[is.na(data$GroupSurvival) & data$Pclass!=3] <- 1\n# make predictions\ndata$Predict <- 0\ndata$Predict[data$Sex=='female'] <- 1\ndata$Predict[data$Title=='woman' & data$GroupSurvival==0] <- 0\ndata$Predict[data$Title=='boy' & data$GroupSurvival==1] <- 1\nx = which(data$Sex=='male' & data$Predict==1 & data$PassengerId>891)\ncat(sprintf('We found %d boys predicted to live\\n',length(x)))\nx = which(data$Sex=='female' & data$Predict==0 & data$PassengerId>891)\ncat(sprintf('We found %d females predicted to die\\n',length(x)))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"610b70aadbd710768900a2133578c79149a4acb2"},"cell_type":"code","source":"submit <- data.frame(PassengerId=892:1309,Survived=data$Predict[892:1309])\nsubmit$Survived[maleLive-891] <- 1\nwrite.csv(submit,'WCG_XGBoost1.csv',row.names=F)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"58d691a040537ac7350ced4225aa191d59e03368"},"cell_type":"markdown","source":"- 성인 남성이 생존할 것으로 예측한 절반이 옳았고 절반은 잘못되었다고 생각됩니다. \n- WCG 제출과 함께 추가로 4 가지 예언을 통해 WCG 점수가 변경되지는 않았지만 교차 검증을 통해 다음과 같은 결과를 얻을 수 있습니다 . 그러나 우리는 성인 남성 1 ~ 2 명을 발견했습니다.\n\n\n# Explore solo females survival with XGBoost\n- XGBoost 기술을 솔로 여성에게 적용해 봅시다. 솔로 여성의 생존율을 정확하게 예측할 수 있다면 WCG 모델과 결합하여 가장 정확한 타이타닉 모델을 구할 수 있습니다! \n- 훈련 데이터 세트에는 304 명의 여성이 포함되어 있습니다. 그 중 108 명이 WCG에, 126 명이 솔로로, 80 명이 동생이나 남편과 함께 여행하며 아이들이 없습니다. 여기에서는 솔로 여성을 탐구 할 것입니다."},{"metadata":{"_kg_hide-input":true,"trusted":true,"_uuid":"a13427eb18ee37641580d400b129b310025f9aed"},"cell_type":"code","source":"# identify WCG females\nWCGtrain = which(data$Passenger<=891 & (data$GroupSurvival==0 | data$GroupSurvival==1))\nWCGtest = which(data$Passenger>891 & (data$GroupSurvival==0 | data$GroupSurvival==1))\n# identify solo females\ndata2 <- data[data$PassengerId<=891 & data$Title=='woman' & data$FamilySize==1,]\ndata3 <- data.frame(y=data2$Survived,x1=data2$FareAdj/10,x2=data2$Age/15,Pclass=data2$Pclass)\n# set zoom\nx1s <- seq(0.5, 1.5, length.out = 100)\nx2s <- seq(1, 3, length.out = 100)\ng <- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\n\ndim(data3)\nstr(data3)\n\n# classify females with XGBoost\nparam <- list(objective   = \"binary:logistic\",\n              eval_metric = \"error\",\n              max_depth   = 5,\n              eta         = 0.1,\n              gammma      = 0.1,\n              colsample_bytree = 1,\n              min_child_weight = 1)\ncat('XGBoosting begun...\\n')\nxgb <- xgboost(params  = param,\n               data    = data.matrix(data3[,c('x1','x2')]),\n              label   = data3$y, \n              nrounds = 500,\n              print_every_n = 100,\n              verbose = 1)\np <- predict(xgb,newdata=data.matrix(g[,c('x1','x2')]))\ng$y <- ifelse(p<=0.25,0,1)\n# plot results\nggplot(data=data3[data3$x1>0.5 & data3$x1<1.5 & data3$x2>1 & data3$x2<3,]) +\n    xlim(0.5,1.5) + ylim(1,3) +\n    geom_tile(data=g,aes(x1,x2,fill=factor(y))) +\n    geom_density_2d(aes(x1,x2,color=factor(y))) +\n    geom_point(size=2,aes(x1,x2,color=factor(y),shape=factor(Pclass))) +\n    scale_color_manual(values=c('#AA0000','#00AA00'),\n        limits=c('0','1'),labels=c('0','1')) +\n    scale_fill_manual(values=c('#FF9999','#99FF99'),\n        limits=c('0','1'),labels=c('0','1')) +\n    labs(x='Fare / (10 x TicketFrequency)',y='Age / 15',shape='Pclass',fill='Classify',\n        title='XGBoost learns the training set\\'s\n        126 solo females. Red is P(die)>=0.75',color='Survived') +\n    geom_vline(xintercept=c(0.8,0.9), linetype='dotted') +\n    annotate('text',x=0.77,y=2.95,label='Fare = $8') +\n    annotate('text',x=0.93,y=2.95,label='Fare = $9') +\n    geom_hline(yintercept=c(1.33,1.67), linetype='dotted') +\n    annotate('text',x=1.35,y=1.61,label='Age = 25') +\n    annotate('text',x=1.35,y=1.28,label='Age = 20')","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"7fb48b4a812bcceff3148760ffdbc3d149e6425f"},"cell_type":"markdown","source":"- XGBoost에서 훈련 데이터 세트의 솔로 여성 중 생존 패턴을 찾은 것 같습니다! \n- 위의 그림에서 가장 유망한 솔로 여성은 Pclass = 3, FareAdj = 9, Age = 22입니다. 또는 Pclass = 3, FareAdj = 8, Age = 34입니다. 음영은 XGBoost의 분류 결정은 있습니다. 빨간색 영역은 P(die)> 0.75를 예측하는 XGBoost에 해당합니다."},{"metadata":{"_uuid":"7eb6934e513bdb26148dc579531fc8f76bee9f1c"},"cell_type":"markdown","source":"## Grid search and cross validation\n- 그리드 검색을 사용하여 XGBoost에 대한 최적의 매개 변수가 treeDepth = 5, p <= 0.08임을 알 수 있습니다. 그리드 검색을 수행하려면 아래 코드에서 for 루프의 주석 처리를 제거하고 검색 할 하이퍼 매개 변수를 추가하십시오.이 노트에서는 그리드 검색을 수행하지 않습니다. 이제 XGBoost가 CV = 78.6 % 인 성별 모델보다 더 정확한지 확인하기 위해 교차 유효성 검사를 수행해 봅시다."},{"metadata":{"_kg_hide-input":true,"trusted":true,"_uuid":"4fab6ee6b21cf70b2b53ea6f0d3b756ba6739022"},"cell_type":"code","source":"#accuracy = matrix(nrow=4,ncol=4)\n#rownames(accuracy) <- c('d=3','d=4','d=5','d=6')\n#colnames(accuracy) <- c('0.08','0.10','0.25','0.50')\n#for (j in 1:4)\n#for (k in 1:4){\ntrials=100; sum=0\nfor (i in 1:trials){\n    s = sample(1:891,800)\n    s2 = (1:891)[-s]\n    dataB <- data[data$PassengerId %in% s & data$Title=='woman' & data$FamilySize==1,]\n    dataC <- data[data$PassengerId %in% s2 & data$Title=='woman'& data$FamilySize==1,]\n    data$Predict <- 0\n    data$Predict[data$Sex=='female'] <- 1\n    dataTrain <- data.frame(y=dataB$Survived,x1=dataB$FareAdj/10,x2=dataB$Age/15)\n    dataTest <- data.frame(y=dataC$Survived,x1=dataC$FareAdj/10\n        ,x2=dataC$Age/15,PassengerId=dataC$PassengerId)\n    param <- list(objective   = \"binary:logistic\",\n              eval_metric = \"error\",\n              max_depth   = 5,\n              eta         = 0.1,\n              gammma      = 0.1,\n              colsample_bytree = 1,\n              min_child_weight = 1)\n    xgb <- xgboost(params  = param,\n              data    = data.matrix(dataTrain[,c('x1','x2')]),\n              label   = dataTrain$y, \n              nrounds = 500,\n              silent = 1,\n              print_every_n = 100,\n              verbose = 0)\n    p <- predict(xgb,newdata=data.matrix(dataTest[,c('x1','x2')]))\n    dataTest$p <- ifelse(p<=0.08,0,1)\n    data$Predict[dataTest$PassengerId] <- dataTest$p \n    sm = sum(abs(data$Predict[s2] - data$Survived[s2]))\n    cv = 1 - sm/length(s2)\n    #if (i %% 25==0) \n    #cat(sprintf('Trial %d has CV = %f\\n',i,cv))\n    sum = sum + cv\n}\ncat(sprintf('Average CV of %d trials = %f\\n',trials,sum/trials))\n#accuracy[j,k] <- sum/trials\n#}\n#accuracy","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"ccf503c30530b6fbc6bf74b0698e9ee91918205a"},"cell_type":"markdown","source":"- CV 정확도는 79.0 %입니다. (위에 표시된 결과는 k 배 CV의 무작위 특성으로 인해 달라질 수 있지만 오프라인에서는 10,000 회의 평가에서 79.0 %를 확인했습니다.) 성별 모델의 CV 정확도는 78.6 %이므로 약간 개선되었습니다. 바라건대, 우리는 공개 점수에도 약간의 개선을 이룰 수 있습니다. 어디 보자.\n\n\n## Submission to Kaggle"},{"metadata":{"_kg_hide-input":true,"trusted":true,"_uuid":"111b732164fb2b525ed1b2788ab69438815ccce0"},"cell_type":"code","source":"dataB <- data[data$PassengerId %in% 1:891 & data$Title=='woman' & data$FamilySize==1,]\ndataC <- data[data$PassengerId %in% 892:1309 & data$Title=='woman' & data$FamilySize==1 \n    & !data$PassengerId %in% WCGtest,]\ndata$Predict <- 0\ndata$Predict[data$Sex=='female'] <- 1\ndataTrain <- data.frame(y=dataB$Survived,x1=dataB$FareAdj/10,x2=dataB$Age/15)\ndataTest <- data.frame(y=dataC$Survived,x1=dataC$FareAdj/10\n    ,x2=dataC$Age/15,PassengerId=dataC$PassengerId,Pclass=dataC$Pclass)\nparam <- list(objective   = \"binary:logistic\",\n              eval_metric = \"error\",\n              max_depth   = 5,\n              eta         = 0.1,\n              gammma      = 0.1,\n              colsample_bytree = 1,\n              min_child_weight = 1)\nxgb <- xgboost(params  = param,\n              data    = data.matrix(dataTrain[,c('x1','x2')]),\n              label   = dataTrain$y, \n              nrounds = 500,\n              silent = 1,\n              print_every_n = 100,\n              verbose = 0)\np <- predict(xgb,newdata=data.matrix(dataTest[,c('x1','x2')]))\ndataTest$p <- ifelse(p<=0.08,0,1)\ndata$Predict[dataTest$PassengerId] <- dataTest$p \nfemalePerish = which(data$Title=='woman' & data$Predict==0)\ncat(sprintf('The following %d females are predicted to die\\n',length(femalePerish)))\ndata[femalePerish,c('PassengerId','Pclass','Name','Age','SibSp','Parch','FareAdj')]","execution_count":null,"outputs":[]},{"metadata":{"_kg_hide-input":true,"trusted":true,"_uuid":"3508715bb323bac2a811f0e656b0e5d1972ff98a"},"cell_type":"code","source":"x1s <- seq(0.6, 1, length.out = 100)\nx2s <- seq(1, 3, length.out = 100)\ng <- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\np <- predict(xgb,newdata=data.matrix(g[,c('x1','x2')]))\ng$y <- ifelse(p<=0.08,0,1)\ng1 <- ggplot(data=dataTest[dataTest$x1<1 & dataTest$x2<3,]) +\n    xlim(0.6,1) + ylim(1,3) +\n    geom_tile(data=g,aes(x1,x2,fill=factor(y))) +\n    geom_point(size=2,aes(x1,x2,color=factor(p),shape=factor(Pclass))) +\n    scale_color_manual(values=c('#0000FF','#666666'),\n        limits=c('0','1'),labels=c('0','1')) +\n    scale_fill_manual(values=c('#FF9999','#99FF99'),\n        limits=c('0','1'),labels=c('0','1')) +\n    labs(x='Fare / (10 x TicketFrequency)',y='Age / 15',shape='Pclass',fill='Classifier',\n        title='XGBoost classifies the test set.\n        It predicts 10 non-WCG females have P(die)>=0.92',color='Predict') +\n    geom_vline(xintercept=c(0.8,0.9), linetype='dotted') +\n    geom_hline(yintercept=c(1.33,1.67), linetype='dotted') +\n    annotate('text',x=0.8,y=2.95,label='Fare = $8') +\n    annotate('text',x=0.9,y=2.95,label='Fare = $9') +\n    annotate('text',x=0.65,y=1.61,label='Age = 25') +\n    annotate('text',x=0.65,y=1.28,label='Age = 20')\n# plot passenger numbers\nv = c(0.07,0.02,0.02,0.02,-0.04,0.02,0.02,0.02,0.02,0.02); c = 0\nfor (i in which(dataTest$p==0)){\n    c = c + 1;\n    g1 <- g1 + annotate('text',x=dataTest$x1[i]+0.015,y=dataTest$x2[i]+v[c],label=dataTest$PassengerId[i]\n        ,color='darkblue',size=3)\n}\ng1","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"9f3beb2366557e7e3f15a40529a98e016677da30"},"cell_type":"code","source":"submit$Survived[femalePerish-891] <- 0\nwrite.csv(submit,'WCG_XGBoost2.csv',row.names=F)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"5b1e323c6ceadce25dbacfb4924eb4e6ab69ead3"},"cell_type":"markdown","source":"![result-female](http://playagricola.com/Kaggle/surnameModel5.png)\n\n- 굉장해! 대부분의 여성들의 예측이 옳았다. 우리 점수는 83.3 %에서 84.7 %로 증가했습니다 !! 이것은 우리의 10 가지 여성 예측 중 80 %가 정확하고 좋았음을 의미합니다. 와우, 우리는 이제까지 가장 정확한 타이탄 모델을 가지고 있습니다!"},{"metadata":{"_uuid":"813546fa6fef9686024c8faa82e4b594bffa30ca"},"cell_type":"markdown","source":"## Comparison with CART, kNN, SVM, Random Forest\n\n- 아래는 Pclass = 3 (60 명의 여성)으로 제한된 솔로 여성을 다양한 방법으로 분류하는 방법을 보여줍니다. CART, kNN 및 SVM 교차 검증은 78.9 % 및 랜덤포레스트 78.7 %입니다. \n- 네 가지 모델은 WCG에서 16, 16, 6,  9 솔로 여성에 대해서 예측을 변경하고 83.8 %, 83.3 %, 83.3 % 및 84.2 %의 점수를 각각 획득합니다. (WCG는 그 자체로 83.3 %를 얻습니다.) \n- Random Forest에 의해 생성 된 영역은 위의 XGBoost와 가장 유사합니다. 그리고 가장 비슷한 점수를 얻습니다. CART는 매우 읽기 쉽기 때문에 좋습니다. CART는 P class = 3의 솔로 여학생이 FareAdj > $8 or Age > 25 로 사망한다고 말합니다. 이 패턴은 학습 데이터 세트에 있습니다. 이 조건들을 충만한 22 명의 여성 중 64 % = 14/22 명이 사망합니다.\n"},{"metadata":{"_kg_hide-input":true,"trusted":true,"_uuid":"98c26b4f688106d323285ff411723ed1ee1e8ff2"},"cell_type":"code","source":"g = list(); gp = list()\ngt = c('CART learns the training set','kNN k=5 learns the training set'\n       ,'SVM with radial kernel','Random Forest with P(die)>0.75')\ndata2 <- data[data$PassengerId<=891 & data$Title=='woman' & data$FamilySize==1 & data$Pclass==3,]\ndata3 <- data.frame(y=data2$Survived,x1=data2$FareAdj/10,x2=data2$Age/15)\n# set zoom\nx1s <- seq(0.6, 1, length.out = 50)\nx2s <- seq(1, 3, length.out = 50)\nfor (i in 1:4){\n    g[[i]] <- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\n    if (i==1){\n        fit <- rpart(factor(y) ~ x1 + x2,data3)\n        p <- predict(fit,newdata=g[[i]])[,2]\n        g[[i]]$y <- ifelse(p<=0.5,0,1)\n    } else if (i==2){\n        fit <- knn3(factor(y) ~ x1 + x2,data3,k=3)\n        p <- predict(fit,newdata=g[[i]])[,2]\n        g[[i]]$y <- ifelse(p<=0.5,0,1)\n    } else if (i==3){\n        fit <- svm(factor(y)~ x1 + x2,data3,kernel='radial')\n        p <- predict(fit,newdata=g[[i]])\n        g[[i]]$y <- as.numeric(as.character(p))\n    } else if (i==4){\n        fit <- randomForest(factor(y) ~ x1 + x2,data3)\n        p <- predict(fit,newdata=g[[i]],type='prob')[,2]\n        g[[i]]$y <- ifelse(p<=0.25,0,1)\n    }\n    # plot results\n    gp[[i]] <- ggplot(data=data3[data3$x1>0.6 & data3$x1<1 & data3$x2>1 & data3$x2<3,]) +\n        xlim(0.6,1) + ylim(1,3) +\n        geom_tile(data=g[[i]],aes(x1,x2,fill=factor(y)),show.legend=F) +\n        geom_point(size=1.5,aes(x1,x2,color=factor(y)),show.legend=F) +\n        scale_color_manual(values=c('#AA0000','#00AA00'),\n            limits=c('0','1'),labels=c('0','1')) +\n        scale_fill_manual(values=c('#FF9999','#99FF99'),\n            limits=c('0','1'),labels=c('0','1')) +\n        #labs(x='Fare / (10 x TicketFrequency)',y='Age / 15',fill='Classify',\n        labs(x='',y='',title=gt[i],color='Survived') +\n        geom_vline(xintercept=c(0.8,0.9), linetype='dotted') +\n        geom_hline(yintercept=c(1.33,1.67), linetype='dotted')\n}\ngrid.arrange(gp[[1]],gp[[2]],gp[[3]],gp[[4]],nrow=2)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"bc9d7c9a5aba8ee3931ac68dcc13322359bde0ca"},"cell_type":"markdown","source":"# Conclusion\n\n- 해당 튜토리얼 노트는 성인 남성의 생존을 예측하는 것이 매우 어렵다는 것을 보여주었습니다. \n- 위의 분석에서, 훈련 데이터에서 성인 남성 생존 패턴이 있는 것으로 보인다. 그러나 이러한 패턴은 테스트 데이터 집합으로 이어지지는 않습니다. \n    - 저는 성인 남성이 Pclass, Age, Family Size 및 Fare만으로도 생존 할 수 있다고 예측할 수는 없다고 생각합니다. 훈련 세트가 당신을 속일 수 있다고 생각하게 만듭니다. 남성의 생존을 예측하려면 기능을 설계해야 합니다.\n\n- 여성에 관해서는 예측이 더 성공적입니다. WCG 모델 자체만으로도 많은 여성들을 발견되지만,해당 커널은 non-WCG 여성들간에 여전히 패턴이 있음을 보여줍니다. \n    - 예를 들어, 훈련 세트에는 Pclass = 3 인 6 명의 독신 여행 여성이 있고, $ 8 ~ $ 9 사이의 FareAdj, 20 ~ 25 세의 여성이 있습니다.이 여성 6 명 모두 사망했습니다. 그게 하나의 패턴입니다. \n    - Pclass, Age, Family Size 및 Fare를 사용하여 우리는 여성 모델이 성공할 것이라고 예측할 수 있다는 것을 보여주었습니다. 우리는 또한 FareAdj가 8 세 근처에 있고 34 세 근처에있는 여성이 멸망 할 가능성이 있음을 발견했습니다.\n\n- 우리는 85 %보다 잘 할 수 있습니까? WCG 모델은 84.4 %의 CV와 83.3 %의 점수를 견고하게 달성 할 수 있습니다. 이 커널은 데이터에 더 많은 패턴이 있고 Mega Model의 앙상블이 데이터에 더 많은 패턴이 있음을 보여 줬습니다. 여기 XGBoost가 메가 모델의 앙상블보다 다른 여성을 찾았다는 것은 고무적입니다. \n    - 이는 단일 모델이 아직 모든 non WCG 여성을 분류하지 못했다는 것을 의미합니다. 모든 사람들이 WCG가 아닌 승객을 위해 분류기를 직접 만들어이 커널을 포크하고 개선 할 것을 권장합니다. (참고 :이 커널을 포크하는 경우 설정에서 GPU를 켜십시오)\n\nXGBoost에 대해 더 자세히 알고 싶다면 Tae Hyon Whang의 XGBoost, 173/209 LB가있는 Titanic Starter라고 불리는 위대한 Python 커널을 확인하십시오.\nTo learn more about XGBoost, check out [Tae Hyon Whang's][1] great Python kernel called [Titanic Starter with XGBoost, 173/209 LB][2].  \n  \n[1]:https://www.kaggle.com/numbersareuseful\n[2]:https://www.kaggle.com/numbersareuseful/titanic-starter-with-xgboost-173-209-lb\n"},{"metadata":{"_uuid":"14d091833121a4d676b3d5d0ba42ab0eb2148eec"},"cell_type":"markdown","source":"# Summary of Titanic models\n Here's a review of this notebook and my previous two. First the population was divided into 5 groups:  \n* (A) Males adults - 61% of population  \n* (B) Males boys (Master title) - 5% of population  \n* (C) Females that have children, sisters, or mothers (brothers, husbands optional) - 12%\n* (D) Females that have brothers, or husbands (no children, no sisters, no mothers) - 8%  \n* (E) Females traveling alone - 14% of population  \n  \nNext we built 3 classifiers:    \n* (1) [WCG classifies B+C][1]  \n* (2) [Ensemble of top 5 Kaggle classifies A+D+E][1]  \n* (3) [XGBoost classifies E][2]  \n  \nFinally we assembled 4 models. Here are cross validations and public scores:  \n* WCG + GenderModel = 84.4% CV and 83.3% PS  \n* WCG + Ensemble = unknown CV and 84.2% PS  \n* WCG + XGBoost + GenderModel = 85.2% CV and 84.7% PS  \n* WCG + XGBoost + Ensemble = unknown CV and 85.2% PS  \n\nThank you for reading my notebook #3! I hope you enjoyed it. Check out notebooks [#1][3] and [#2][1]. Feel free to use my classifiers, improve them, add your own, and assemble new models. I believe it is possible to increase CV and PS above 85%. Good luck! (_NOTE: if you fork this kernel, turn on GPU under settings_)  \n  \n[1]:https://www.kaggle.com/cdeotte/titantic-mega-model-0-84210\n[2]:https://www.kaggle.com/cdeotte/titanic-wcg-xgboost-0-84688\n[3]:https://www.kaggle.com/cdeotte/titanic-using-name-only-0-81818"},{"metadata":{"_uuid":"6af53ed5b639b9e8c6ed594f34de1e78219d363b"},"cell_type":"markdown","source":"![hist](http://playagricola.com/Kaggle/histXGB.png)"}],"metadata":{"kernelspec":{"display_name":"R","language":"R","name":"ir"},"language_info":{"mimetype":"text/x-r-source","name":"R","pygments_lexer":"r","version":"3.4.2","file_extension":".r","codemirror_mode":"r"}},"nbformat":4,"nbformat_minor":1}