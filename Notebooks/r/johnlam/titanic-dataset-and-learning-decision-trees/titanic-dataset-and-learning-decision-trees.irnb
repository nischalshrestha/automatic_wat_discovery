{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "_cell_guid": "e342f554-4421-5b75-18f6-c0b68d57bbec"
      },
      "source": [
        "The goal of this notebook is to convert the excellent introduction to decision trees tutorial from DataCamp into a Notebook format. This lets me take notes as I learn the underlying technology."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "_cell_guid": "f062e52f-a9ba-557b-1c04-0a7c01cbedc6"
      },
      "source": [
        "First, let's load the training and testing datasets. You can use the Kaggle input dataset viewer to see the data from above. I like the fact that this stuff all lives _relative_ to the current working directory of the notebook itself. This makes it super easy to conceptualize. Presumably all of the input data is refreshed on a Kernel restart. I wonder what happens with output files? "
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "e27a6526-2ce1-8752-56d3-8e6b61d0298b"
      },
      "outputs": [],
      "source": [
        "library(dplyr)\n",
        "\n",
        "# Read the raw data\n",
        "train <- read.csv(\"../input/train.csv\")\n",
        "test <- read.csv(\"../input/test.csv\")\n",
        "\n",
        "# Look at the dimensions of the datasets\n",
        "dim(train)\n",
        "dim(test)\n",
        "\n",
        "# Generate a combined dataset for cross validation\n",
        "# Note initial errors about coercing factors to characters\n",
        "full <- bind_rows(train, test)\n",
        "dim(full)\n",
        "\n",
        "head(full)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "_cell_guid": "daf044bc-2cdb-f656-87ac-0f387248a18a"
      },
      "source": [
        "The following doesn't seem to work, as the Kaggle kernel doesn't allow insertion of arbirary HTML from\n",
        "packages like googleVis. That's understandable, but given the right HTML sanitizer it would be a righteous feature."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "491833ad-7352-43a7-30a5-6ee23a16fec0"
      },
      "outputs": [],
      "source": [
        "# These don't seem to work, as the Kaggle kernel doesn't allow insertion of arbirary HTML from\n",
        "# packages like googleVis.\n",
        "\n",
        "# suppressPackageStartupMessages(library(googleVis))\n",
        "# gvisTable(train)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "_cell_guid": "e34dccbd-2f7b-f3c9-a1a0-e2d8f7946c3c"
      },
      "source": [
        "Now let's take a look at these datasets. First notice that the `train` dataset contains a `Survived` column, which is the label. It would be nice to eyeball the data using better technology than these formats."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "5bdd01a7-5fa6-f54c-45b6-6a0907866165"
      },
      "outputs": [],
      "source": [
        "str(train)\n",
        "head(train)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "0c25413a-e92d-b8a8-b206-1d979a827505"
      },
      "outputs": [],
      "source": [
        "str(test)\n",
        "head(test)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "_cell_guid": "5c2f9ac1-492a-a957-c5c7-95c14e6f69cf"
      },
      "source": [
        "# First attempt: Decision Trees\n",
        "\n",
        "First, let's load the rpart library, which is the R package for Recursive Partitioning and Regression Trees."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "6ae7f674-921e-dce2-a69b-9e5f3bd88e45"
      },
      "outputs": [],
      "source": [
        "library(rpart)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "_cell_guid": "74dc7ac8-4217-71c1-7b48-0e142ea28f7f"
      },
      "source": [
        "Now, let's generate a decision tree based on the following features, and plot the tree that was generated by the algorithm:\n",
        "\n",
        "- Pclass\n",
        "- Sex\n",
        "- Age\n",
        "- Sibsp\n",
        "- Parch\n",
        "- Fare\n",
        "- Embarked`enter code here`\n",
        "\n",
        "Note that it is interesting that this algorithm runs just fine with missing data values, but when attempting to run using cross validation, it fails to run as there are missing values in the prediction."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "b6a06463-8afe-65c2-0f58-f67fab404d98"
      },
      "outputs": [],
      "source": [
        "decision_tree <- rpart(\n",
        "    Survived ~ Pclass + Sex + Age + SibSp + Parch + Fare + Embarked, \n",
        "    data = train, \n",
        "    method = \"class\")\n",
        "\n",
        "# Load the packages to build the fancy plot\n",
        "library(rattle)\n",
        "library(rpart.plot)\n",
        "library(RColorBrewer)\n",
        "\n",
        "# Plot the tree\n",
        "fancyRpartPlot(decision_tree)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "_cell_guid": "867ce4cd-03f8-74cd-c7f9-3ae76ca6e6d6"
      },
      "source": [
        "Run the decision tree to generate our solution dataframe and write the output to my_solution.csv, which is the standard Kaggle submission filename. This file then needs to be uploaded to generate a result. Before doing this, it would be useful to test it locally before generating a submission."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "922a26fb-9cc3-14c3-be31-08ebe4edb1e7"
      },
      "outputs": [],
      "source": [
        "prediction_1 <- predict(decision_tree, newdata = test, type = \"class\")\n",
        "solution_1 <- data.frame(PassengerId = test$PassengerId, Survived = prediction_1)\n",
        "write.csv(solution_1, file = \"my_solution.csv\", row.names = FALSE)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "_cell_guid": "a91a0c3b-c465-f50e-9987-4a36bc82f2e9"
      },
      "source": [
        "# Data Engineering\n",
        "\n",
        "Clean up the data before we can run cross validation on it. Which columns have missing values? From the summary() function, we need to clean up:\n",
        "\n",
        "- Age\n",
        "- Fare"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "030cd0d8-414d-b76c-b130-54c1c14d8dba"
      },
      "outputs": [],
      "source": [
        "# summary() will give me NAs for numerical values, but we need to treat NA for strings as empty strings\n",
        "summary(full)\n",
        "\n",
        "# identify passenger without fare\n",
        "id <- full[which(is.na(full$Fare)), 1]\n",
        "full[id,]\n",
        "\n",
        "# compute what the fare should be by computing the median fare of 3rd class passengers who left from\n",
        "# Southhampton\n",
        "\n",
        "median_fare <- full %>%\n",
        "    filter(Pclass == '3' & Embarked == 'S') %>%\n",
        "    summarise(missing_fare = median(Fare, na.rm = TRUE))\n",
        "\n",
        "median_fare"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "d3cbf371-1697-564e-c941-751b0e4a6728"
      },
      "outputs": [],
      "source": [
        "# characters need special handling as well because it is not obvious\n",
        "full$Embarked[full$Embarked == \"\"] <- NA\n",
        "full[which(is.na(full$Embarked)), 1]\n",
        "\n",
        "full$Cabin[full$Cabin == \"\"] <- NA\n",
        "full[which(is.na(full$Cabin)), 1]"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "_cell_guid": "0a042255-efaf-2591-ba7d-e62aba1a502b"
      },
      "source": [
        "# Cross Validation"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "a42cdf29-b097-b019-248a-988b15c9b09d"
      },
      "outputs": [],
      "source": [
        "library(caret)\n",
        "\n",
        "controlParameters <- trainControl(\n",
        "    method = \"cv\",\n",
        "    number = 10,\n",
        "    repeats = 10,\n",
        "    verboseIter = TRUE\n",
        ")\n",
        "\n",
        "decision_tree_model <- train(\n",
        "    Survived ~ Pclass + Sex + Age + SibSp + Parch + Fare + Embarked, \n",
        "    data = full,\n",
        "    trControl = controlParameters,\n",
        "    method = \"rpart\",\n",
        "    na.action = na.omit\n",
        ")\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "_cell_guid": "881e5b52-87ed-0b6b-246c-e6aff76f3e2b"
      },
      "source": [
        "# Data Preperation\n",
        "\n",
        "In this section, I will spend some time examining the data to clean it up before feeding to the same model."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "9f790466-d78e-17bb-a296-9846761f1b86"
      },
      "outputs": [],
      "source": [
        "train_1 <- data.frame(train$Pclass, train$Sex, train$Age, train$SibSp, train$Parch, train$Fare, train$Embarked)\n",
        "head(train_1)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "d08c5b55-1c1f-5da0-eb9a-46800efc94f8"
      },
      "outputs": [],
      "source": [
        "plot(train)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "c5cf1694-1c96-dccb-ee55-1dc61018890a"
      },
      "outputs": [],
      "source": [
        "summary(solution_1)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "_cell_guid": "3c92207b-ab09-7b8a-1724-71e9df68846f"
      },
      "outputs": [],
      "source": ""
    }
  ],
  "metadata": {
    "_change_revision": 0,
    "_is_fork": false,
    "kernelspec": {
      "display_name": "R",
      "language": "R",
      "name": "ir"
    },
    "language_info": {
      "codemirror_mode": "r",
      "file_extension": ".r",
      "mimetype": "text/x-r-source",
      "name": "R",
      "pygments_lexer": "r",
      "version": "3.3.2"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}