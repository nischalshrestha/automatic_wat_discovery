{"metadata": {"kernelspec": {"language": "R", "display_name": "R", "name": "ir"}, "language_info": {"name": "R", "pygments_lexer": "r", "mimetype": "text/x-r-source", "version": "3.4.1", "codemirror_mode": "r", "file_extension": ".r"}}, "nbformat_minor": 1, "cells": [{"source": ["# Implementing Various Models on Titanic Dataset\n", "\n", "### *HyeongKyu Froilan Choi*\n", "\n", "### initiated kernel at Oct 26, 2017\n", "### Not yet finished\n", "###   \n", "###   \n", "<hr>"], "cell_type": "markdown", "metadata": {"_uuid": "d933bfcf7d3c9fee88caad3350c412ac6a101bb9", "_cell_guid": "277d364f-f0e7-48ac-afac-559c1344a8b2"}}, {"source": ["### [[ CONTENTS ]]\n", "[1. DATA IMPORT](#1) <br>\n", "&nbsp;&nbsp; [1.1 STAGING THE DATA](#1.1) <br>\n", "&nbsp;&nbsp; [1.2 PEEKABOO!](#1.2) <br>\n", "&nbsp;&nbsp; [1.3 QUICK INSIGHT INTO THE DATA](#1.3) <br>\n", "[2. EXPLORATORY DATA ANALYSIS](#2) <br>\n", "&nbsp;&nbsp; [2.1 SELECTING VARIABLES](#2.1) <br>\n", "&nbsp;&nbsp; [2.2 VISUALIZING AS IT IS](#2.2) <br>\n", "&nbsp;&nbsp; [2.3 EXPLORATION ON 'AGE'](#2.3) <br>\n", "[3. PREDICTING THE 'AGE'](#3) <br>\n", "&nbsp;&nbsp; [3.1 WHAT VARIABLES TO USE?](#3.1) <br>\n", "&nbsp;&nbsp; [3.2 MULTILINEAR REGRESSION MODEL FOR AGE](#3.2) <br>\n", "&nbsp;&nbsp; [3.3 ARTIFICIAL NEURAL NETWORK MODEL FOR AGE](#3.3) <br>\n", "&nbsp;&nbsp; [3.4 FILLING IN THE NAs IN AGE](#3.4) <br>\n", "\n", "###    \n", "<hr>"], "cell_type": "markdown", "metadata": {"_uuid": "f23840d760fae98251f20cbc9e01724ae10ff45b", "_cell_guid": "534ade37-107d-4b19-9925-2135f1bead9e"}}, {"source": ["<a class='anchor' id='1'> </a>\n", "# 1. DATA IMPORT"], "cell_type": "markdown", "metadata": {"_uuid": "1a96d5b0dcead6adddac2e818ba7eb8bc9a1be12", "_cell_guid": "4ccfdbc1-bc85-4bb5-a4d0-3a0bd810049e"}}, {"source": ["<a class='anchor' id='1.1'></a>\n", "## &nbsp;&nbsp;1.1 STAGING THE DATA"], "cell_type": "markdown", "metadata": {"_uuid": "de1f7b1ef60de9cbcd2be81a2040f801b8c0a00e", "_cell_guid": "979e82c8-b1e2-44d5-b4bd-d2205b8ecf41"}}, {"execution_count": null, "source": ["data <- read.csv(\"../input/train.csv\")\n", "question <- read.csv(\"../input/test.csv\")"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "943dd8184a05415125452b789611fae854251670", "_cell_guid": "b1aa00cf-fee9-4720-8bdd-3d840ed61659"}}, {"source": ["<a class='anchor' id='1.2'></a>\n", "## &nbsp;&nbsp;1.2 PEEKABOO!\n", "### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.1 TRAIN.CSV\n", "> SUMMARY"], "cell_type": "markdown", "metadata": {"_uuid": "e4cac7e69535ff4422f7a5c2f6a7042ca78cc6ff", "_cell_guid": "47b670b8-d872-418a-b3b1-8b7ea096ee4c"}}, {"execution_count": null, "source": ["summary(data)"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "4866284eb7f8e504c276ac4dd7df3aefd7c6020f", "_kg_hide-input": true, "_cell_guid": "60ae0a56-4634-4c0e-88c9-5f0844e00671"}}, {"source": ["> STRUCTURE"], "cell_type": "markdown", "metadata": {"_uuid": "2cf894e17ec444a9bc90beb87a293f77c6233488", "_cell_guid": "e5402bb7-57e0-4c45-9a3d-29668ac83df3"}}, {"execution_count": null, "source": ["str(data)"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "1e8a9c91a4daf5a16b6be7c7ee86eb68d8133290", "_kg_hide-input": true, "_cell_guid": "35c01d2f-2b4e-400a-8ef1-4117942b350e"}}, {"source": ["### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.2 TEST.CSV\n", "> SUMMARY"], "cell_type": "markdown", "metadata": {"_uuid": "b488d9aa46abe268f52870ba2072452093d3716e", "_cell_guid": "d3a0241f-d629-42df-9083-648ad8a7f161"}}, {"execution_count": null, "source": ["summary(question)"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "e41ee9c6fa8649fac35cc14a8a716d6ba79b2b16", "_kg_hide-input": true, "_cell_guid": "cb2ed2a0-e7f6-421f-8e9a-ab92109fdb80"}}, {"source": ["> STRUCTURE"], "cell_type": "markdown", "metadata": {"_uuid": "a99726cc518cb2844b5e7a4dc5ef8cb4e8ab4665", "_cell_guid": "1a93c762-986b-47d0-aa5d-db4fb0bff045"}}, {"execution_count": null, "source": ["str(question)"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "1596804d83bf9fb3fa059af0a22c206f2517e01e", "_kg_hide-input": true, "_cell_guid": "eb1a4d81-e4bc-42c6-b22a-f468ff892753"}}, {"source": ["<a class='anchor' id='1.3'></a>\n", "## &nbsp;&nbsp;1.3 QUICK INSIGHT INTO THE DATA\n", "    1. Missing values are in 'Age' & 'Embarked' for train.csv,\n", "                             'Age' & 'Fare' for test.csv\n", "    2. Properly estimating the 'Age' would be a big deal in the success of modeling\n", "    3. The one missing value in test.csv 'Fare', could be roughly predicted proportionally using 'Pclass'\n", "    4. 'PassengerId', 'Name', 'Ticket' and 'Cabin' seems irrelevant"], "cell_type": "markdown", "metadata": {"_uuid": "dcaeaa3fd1f11236a4950132b78c323722ed5351", "_cell_guid": "dce853e1-8071-4815-aa71-974406561b98"}}, {"source": ["<a class='anchor' id='2'></a>\n", "# 2. EXPLORATORY DATA ANALYSIS"], "cell_type": "markdown", "metadata": {"_uuid": "f3c415980787d8f3456f7003201826d977d46606", "_cell_guid": "fb3b41ee-4bf8-4722-b385-6842b012838f"}}, {"source": ["<a class='anchor' id='2.1'></a>\n", "## &nbsp;&nbsp;2.1 SELECTING VARIABLES\n", "I selected variables that seemed relevant to survival;  'Survived', 'Pclass', 'Sex', 'Age', 'SibSp', 'Parch', 'Fare', 'Embarked'. <br> Also, since missing values in the 'Embarked' variable is trivial, I decided to leave those lines out of our story."], "cell_type": "markdown", "metadata": {"_uuid": "74e95626417329f3f42b5fb66f6c3150a817952a", "_cell_guid": "a71e14e1-8e04-4b11-92ee-40fd34d7f058"}}, {"execution_count": null, "source": ["  data <- data[c('Survived','Pclass','Sex','Age','SibSp','Parch','Fare','Embarked')]\n", "  data <- data[data$Embarked != '',]\n", "  data$Embarked <- as.character(data$Embarked)\n", "  data$Embarked <- as.factor(data$Embarked)"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "20ffe95be15ea193a5810661905001739eb36e9e", "_cell_guid": "516216f7-e69b-4649-9a9d-076c70d1d9c4"}}, {"source": ["<a class='anchor' id='2.2'></a>\n", "## &nbsp;&nbsp;2.2 VISUALIZING AS IT IS\n", "### &nbsp;&nbsp;&nbsp;&nbsp;2.2.1 CATEGORICAL VARIABLES - barplots"], "cell_type": "markdown", "metadata": {"_uuid": "1f3584b1ed7afabdbac5dd294a737c7954833b7c", "_cell_guid": "7cd19d15-dccd-4f33-8dcd-8526f20ece21"}}, {"execution_count": null, "source": ["par(mfrow=c(2,2))\n", "counts <- table(data$Survived)\n", "barplot(counts, main='Survived', names.arg=c('no','yes'), col ='lightpink')\n", "counts <- table(data$Pclass)\n", "barplot(counts, main='PassengerClass', names.arg=c('1st','2nd','3rd'), col='lemonchiffon')\n", "counts <- table(data$Sex)\n", "barplot(counts, main='Gender', names.arg=c('female','male'), col='lemonchiffon')\n", "counts <- table(data$Embarked)\n", "barplot(counts, main='Port of Embarkation', names.arg=c('C','Q','S'), col='lemonchiffon')"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "64d082a5f6edcd3015efe0444e85eea0a3392c87", "_kg_hide-input": true, "_cell_guid": "4d4b761f-cf67-4dee-a238-c110dfb321fe"}}, {"source": ["### &nbsp;&nbsp;&nbsp;&nbsp;2.2.1 CONTINUOUS VARIABLES - histograms"], "cell_type": "markdown", "metadata": {"_uuid": "9fcaf4b089518001ce7ab8e672483068cf81f1ce", "_cell_guid": "e3c36e04-2a04-44ca-ba9a-5ad345170bf1"}}, {"execution_count": null, "source": ["par(mfrow=c(2,2))\n", "hist(data$Age)\n", "hist(data$SibSp)\n", "hist(data$Parch)\n", "hist(data$Fare)"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "c78378aa71783ec0e586a98a3bf5315866d00965", "_kg_hide-input": true, "_cell_guid": "ebe18358-9c25-432c-99e4-e5ad66407081"}}, {"source": ["<a class='anchor' id='2.3'></a>\n", "## &nbsp;&nbsp;2.3 EXPLORATION ON 'AGE'\n"], "cell_type": "markdown", "metadata": {"_uuid": "de5580db817c207b99f97e345eb4d7b89944873f", "_cell_guid": "37a5e50a-4d1c-4068-9642-3b190fea76d7"}}, {"source": ["Before beginning our story into the 'Age' variable, let's pick out the rows that do not have NA in 'Age'."], "cell_type": "markdown", "metadata": {"_uuid": "16f253a4105b83fd9885ebdabc4ffe498b7596ac", "_cell_guid": "32cf36be-332b-4a88-8a14-d405ca1c7ff5"}}, {"execution_count": null, "source": ["age.data <- data[!is.na(data$Age),]"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "6f4338b76506ed331eb4ff8ce16179731728b344", "_cell_guid": "f8879d40-5053-495e-9f50-5bb10f52502b"}}, {"source": ["### &nbsp;&nbsp;&nbsp;&nbsp;2.3.1 AGE & EMBARKED PORT"], "cell_type": "markdown", "metadata": {"_uuid": "d1890f25b757437bd0831d13a203db5ef67abfd0", "_cell_guid": "dd962eaa-a6c0-4c26-9110-cd63f67e0edf"}}, {"execution_count": null, "source": ["par(mfrow=c(1,1))\n", "plot(age.data$Embarked,age.data$Age, main='Age and Embarked Port')"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "1c9b8cf9aaf67eb7b541e9bc201b1f1a11cc59fb", "_kg_hide-input": true, "_cell_guid": "d7d2925e-ad08-4341-bb10-f924db36e977"}}, {"source": ["No notable trend is found between Age and Embarked Port"], "cell_type": "markdown", "metadata": {"_uuid": "72d4005e72cd59bdc0d27bb7b019f22ef0c6228f", "_cell_guid": "116a6396-c66e-43f2-93e7-5ee4fd0dbda3"}}, {"source": ["### &nbsp;&nbsp;&nbsp;&nbsp;2.3.2 AGE & CLASS"], "cell_type": "markdown", "metadata": {"_uuid": "1afda35131691b9a2aa6f5698a75323f0c928ddc", "_cell_guid": "4523bc21-54c5-423e-bc84-bd7d166318cf"}}, {"execution_count": null, "source": ["v<- c(mean(age.data$Age[age.data$Pclass==1]),\n", "      mean(age.data$Age[age.data$Pclass==2]),\n", "      mean(age.data$Age[age.data$Pclass==3]))\n", "barplot(v,main='Age and Class',names.arg=c('1st','2nd','3rd'), col='lemonchiffon')"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "a8764924bb407f6b1706fb2d63e37666e8f05c01", "_kg_hide-input": true, "_cell_guid": "15e6914c-0a11-410f-aad8-081c9704ad5a"}}, {"source": ["For each class, I calculated the mean of ages. The barplot above shows the average age of each economic class.<br>There seems to be a vivid correlation between 'Age' and 'Pclass'. I guess this is a natural outcome since economic status would generally improve as one ages.<br>Anyways, the 'Pclass' variable seems to be a good factor that may help me estimate the NA values in the 'Age' variable."], "cell_type": "markdown", "metadata": {"_uuid": "e3118f5328162172945d325fa874d8e23c81a180", "_cell_guid": "e009d6c9-bb24-49d6-b50f-3c74daa826a3"}}, {"source": ["### &nbsp;&nbsp;&nbsp;&nbsp;2.3.3 AGE & SIBLING/SPOUSE"], "cell_type": "markdown", "metadata": {"_uuid": "9c77020f44b07cb0e3894e22ed95a32b094063ae", "_cell_guid": "1c4da505-a8d7-418d-87a3-cc0050582401"}}, {"execution_count": null, "source": ["v<- c(mean(age.data$Age[age.data$SibSp==0]),\n", "      mean(age.data$Age[age.data$SibSp==1]),\n", "      mean(age.data$Age[age.data$SibSp==2]),\n", "      mean(age.data$Age[age.data$SibSp==3]),\n", "      mean(age.data$Age[age.data$SibSp==4]),\n", "      mean(age.data$Age[age.data$SibSp==5]))\n", "par(mfrow=c(1,2))\n", "barplot(v,main='Age and Sibling/Spouse',names.arg=c(0,1,2,3,4,5), col='lemonchiffon')\n", "hist(data$SibSp)"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "a3690e7ef1073c0b82865d9eca84a54cc4855a8f", "_kg_hide-input": true, "_cell_guid": "bfddd265-e45c-4318-9302-adb7470375db"}}, {"source": ["According to the barplot on the left, there seems to be a negative correlation between 'Age' and 'SibSp'. <br>However, considering the sparse data of 'SibSp' with the value 2 and above, we should be careful in rendering such a conclusion.<br><br>\n", "P.S In the histogram on the right, you'll see 'SibSp' with the value 8, which is not found on the left. This is because the values of 8 had age values of NA. In other words, the mean could not be calculated for the row with data$SibSp equal to 8."], "cell_type": "markdown", "metadata": {"_uuid": "32c3cc2c84b43c5a01396d124036118cf1b254ab", "_cell_guid": "5f032fa0-198b-40db-9be9-f8cc2b99a26d"}}, {"source": ["### &nbsp;&nbsp;&nbsp;&nbsp;2.3.4 AGE & PARENTS/CHILDREN"], "cell_type": "markdown", "metadata": {"_uuid": "1afd49b6c654be739e6937a0cb0f1b0fd2176661", "_cell_guid": "83b15473-52c2-47d0-96bf-74150e957623"}}, {"execution_count": null, "source": ["v<- c(mean(age.data$Age[age.data$Parch==0]),\n", "      mean(age.data$Age[age.data$Parch==1]),\n", "      mean(age.data$Age[age.data$Parch==2]),\n", "      mean(age.data$Age[age.data$Parch==3]),\n", "      mean(age.data$Age[age.data$Parch==4]),\n", "      mean(age.data$Age[age.data$Parch==5]),\n", "      mean(age.data$Age[age.data$Parch==6]))\n", "par(mfrow=c(1,2))\n", "barplot(v,main='Age and Parent/Children',names.arg=c(0,1,2,3,4,5,6), col='lemonchiffon')\n", "hist(data$Parch)"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "dd9e9d4a6b9a1b1ff61ce2356598fd5152d270d2", "_kg_hide-input": true, "_cell_guid": "95760035-aa34-4afa-b44d-13acc642b414"}}, {"source": ["No specific statistical trend can be described"], "cell_type": "markdown", "metadata": {"_uuid": "7a33b3b81f8a30ab7e363a5bb5a7d919112dcee8", "_cell_guid": "fcc647d0-232c-4c9a-b840-b148b2eba94d"}}, {"source": ["### &nbsp;&nbsp;&nbsp;&nbsp;2.3.5 AGE & FAMILY SIZE\n", "Well, if the 'SibSp' and 'Parch' is added, we'll get the family size value. Let's see if that has any meaningful trends."], "cell_type": "markdown", "metadata": {"_uuid": "88bea552f1e4d6f7e10a40adc5f6344fd6416f62", "_cell_guid": "d6bdfd29-bb91-488e-b46c-109c6dd0d42a"}}, {"execution_count": null, "source": ["age.data$FamSize <- age.data$SibSp + age.data$Parch\n", "v<- c(mean(age.data$Age[age.data$FamSize==0]),\n", "      mean(age.data$Age[age.data$FamSize==1]),\n", "      mean(age.data$Age[age.data$FamSize==2]),\n", "      mean(age.data$Age[age.data$FamSize==3]),\n", "      mean(age.data$Age[age.data$FamSize==4]),\n", "      mean(age.data$Age[age.data$FamSize==5]),\n", "      mean(age.data$Age[age.data$FamSize==6]),\n", "      mean(age.data$Age[age.data$FamSize==7]))\n", "barplot(v,main='Age and Family Size',names.arg=c(0,1,2,3,4,5,6,7), col='lemonchiffon')"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "a5bcfa96a8064060f60b3ec8a7e1bd9d20247a45", "_kg_hide-input": true, "_cell_guid": "f3aff666-1a13-412f-b2f1-6ba9916f03b7"}}, {"source": ["Wow, now we can see a quite mild and thorough trend between age and family size. That's a meaningful variable that we can use in predicting age. We'd better use this when predicting the survival of passengers as well! The following code will take care of that for our original dataset."], "cell_type": "markdown", "metadata": {"_uuid": "5aa29b06bc0a23a25d410187a759c58e4d96fe8d", "_cell_guid": "f6779ca9-ff1a-4e89-9bba-1bd948c03826"}}, {"execution_count": null, "source": ["data$FamSize <- data$SibSp + data$Parch"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "4695211c827311ba256aa69afd5126e0bcbb4fed", "_cell_guid": "070698be-b178-4b13-bde8-96bd998ad466"}}, {"source": ["### &nbsp;&nbsp;&nbsp;&nbsp;2.3.5 AGE & FARE"], "cell_type": "markdown", "metadata": {"_uuid": "f003781e6c8f7523d62f4017b9cdd7fad813f72c", "_cell_guid": "528f0d4d-aa8d-46f6-9f56-032c96194e00"}}, {"execution_count": null, "source": ["plot(age.data$Age,age.data$Fare)\n", "sprintf('correlation coefficient : %s',cor(age.data$Age, age.data$Fare))"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "0e61317efc804a192c4d51c925773f775f837717", "_kg_hide-input": true, "_cell_guid": "777bb3d2-93d5-416e-960e-031e820c2d74"}}, {"source": ["The scatterplot and the correlation coefficient tells us that 'Age' and 'Fare' does not have a correlation. Thus, 'Fare' itself would not be a good variable to use for predicting the missing values of 'Age.\n", "<a class='anchor' id='0'></a>\n", "<br><br>\n", "OK, enough of exploration into 'Age'. Now let's try to build a model that may predict the missing values of 'Age'!<br>Follow the link to to jump to 'Age Model'! Don't worry, after your journey, another link will bring you back up here :)<br>--> [Link to the 'Age Model'](#3) <br>\n", "<a class='anchor' id='0'></a>"], "cell_type": "markdown", "metadata": {"_uuid": "f8a3a9d308e04057b6ce6beb3d519339156596f2", "_cell_guid": "08f89c74-1db5-458b-a71e-8526ebf4ec28"}}, {"source": ["<a class='anchor' id='3'></a>\n", "# 3. PREDICTING THE 'AGE'\n", "<a class='anchor' id='3.1'></a>\n", "## &nbsp;&nbsp;3.1 WHAT VARIABLES TO USE?\n", "Judging from 2.3.1~2.3.5, it would be sensible to use 'Pclass', 'SibSp', 'FamSize' as the input variables. These three variables that had high correlations with the 'Age' variable. However, 'SibSp' and 'FamSize' will have a high correlation coefficient as well, which may mean multicollinearity. So let's check for that."], "cell_type": "markdown", "metadata": {"_uuid": "dcdca40b2aca3c8234aea50f16e4aaa33e3c2ae2", "_cell_guid": "6585ed01-c4b6-4e5b-8f2e-d4922f6bd0dd"}}, {"source": [], "cell_type": "markdown", "metadata": {"_uuid": "2bab911ff860e8107b84d461b0bf7a8f02461f61", "_cell_guid": "a0e57614-ed92-4d3d-bbab-94a585c82ce3"}}, {"execution_count": null, "source": ["set.seed(0)\n", "smplSize <-floor(nrow(age.data) * .75)\n", "index <- sample(seq_len(nrow(age.data)), size = smplSize)\n", "age.data.train <- age.data[index, ]\n", "age.data.test <- age.data[-index, ]\n", "#linear regression for age\n", "age.reg <- lm(Age~Pclass+SibSp+FamSize, data=age.data.train)\n", "age.reg.p <- round(predict(age.reg, newdata=age.data.test))\n", "age.reg.p[age.reg.p<0] <- 0\n", "\n", "library(car)\n", "print(\"Variance_Inflation_Factor(VIF)\")\n", "print(vif(age.reg))"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "93177a1061ecf1b896aeef4f454b3870273fdbe6", "_kg_hide-input": true, "_cell_guid": "98bee977-a6fa-427a-994e-f49f66433cd4"}}, {"source": ["Well, as expected, the VIF value tells us that 'SibSp' and 'FamSize' is quite correlated. Nevertheless, the general standard of VIF that we regard as multicollinearity is 10. Therefore, the value above is **not** that significant. We can use both variables in a single multilinear regression model! :)"], "cell_type": "markdown", "metadata": {"_uuid": "286b562d0b1da5ab5ac0c201d76bc84fefa072ce", "_cell_guid": "23ae67a4-1e50-407d-82f3-cf3ce66e0748"}}, {"source": ["<a class='anchor' id='3.2'></a>\n", "## &nbsp;&nbsp;3.2 MULTILINEAR REGRESSION MODEL FOR AGE"], "cell_type": "markdown", "metadata": {"_uuid": "1880d8df07eb63972a1267ab1520e1bc211b21e3", "_cell_guid": "5dc69d0f-81ba-4f2f-845d-ebc8c971e90d"}}, {"execution_count": null, "source": ["set.seed(0)\n", "smplSize <-floor(nrow(age.data) * .75)\n", "index <- sample(seq_len(nrow(age.data)), size = smplSize)\n", "age.data.train <- age.data[index, ]\n", "age.data.test <- age.data[-index, ]\n", "#linear regression for age\n", "age.reg <- lm(Age~Pclass+SibSp+FamSize, data=age.data.train)\n", "age.reg.p <- round(predict(age.reg, newdata=age.data.test))\n", "age.reg.p[age.reg.p<0] <- 0\n", "print(paste(\"sum_of_errors:\",sum(abs(age.reg.p - age.data.test$Age))))\n", "print(paste(\"average_errors:\",sum(abs(age.reg.p - age.data.test$Age))/178))\n", "summary(age.reg)"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "c8b8ca5d3991d66430b732cb7af3a1d334d485fb", "_kg_hide-input": true, "_cell_guid": "3fa08bb7-5958-40e7-a38e-bc6cb28a8992"}}, {"source": ["Okay, now we have the model, **Age = 46.9626 - 6.4283 x Pclass - 3.2447 x SibSp - 0.7578 x FamSize**<br>Taking a look at the 'sum_of_errors', the value is **1875.91**. Considering the length of the test data that I used for evaluating this model, which is 178, the average being approximately **10.54** is not perfect but decent.<br>Anyways, now let's take a look at the ANN model. Maybe we can find a better model."], "cell_type": "markdown", "metadata": {"_uuid": "87d4caf8a81a2b79e4f75c0a501426c9bf136f9a", "_cell_guid": "985a01bb-48c9-4ab1-a8af-4b10b02bd6e0"}}, {"source": ["<a class='anchor' id='3.3'></a>\n", "## &nbsp;&nbsp;3.3 ARTIFICIAL NEURAL NETWORK MODEL FOR AGE"], "cell_type": "markdown", "metadata": {"_uuid": "de5e2ea1c889a854193591e43bbd7a2f19630885", "_cell_guid": "1fa94597-0849-4e4b-aeb8-ddc55c8465a4"}}, {"source": ["In order to get the best model, I generated 100 ANN models and picked one that performed best on the test dataset. Check out my code right below this sentence!"], "cell_type": "markdown", "metadata": {"_uuid": "9f344572ca0f3f9d1ad3abd510aaa5caca6dd939", "_cell_guid": "da13d5ee-3473-4c31-a15d-b53d9b1abf08"}}, {"execution_count": null, "source": ["library(nnet)\n", "errorSum <- 10000\n", "for (i in 1:100){\n", "  age.ann <- nnet(Age~Pclass+SibSp+FamSize, linout = TRUE, data= age.data.train, size = 4, rang= .1,decay=.0005,maxit=1000)\n", "  age.ann.p<- predict(age.ann, newdata=age.data.test)\n", "  tmp <- sum(abs((age.ann.p - age.data.test$Age)))\n", "  if (errorSum > tmp){\n", "    errorSum <- tmp\n", "    final.age.ann <- age.ann\n", "    final.age.ann.p <- age.ann.p\n", "  }\n", "}"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "d3a39c6a7e8d47d4ed4d10e977578d6881a8a3be", "_kg_hide-input": false, "_kg_hide-output": true, "_cell_guid": "882f4590-1940-44bd-bfbe-678fdebe9a3d"}}, {"execution_count": null, "source": ["plot.nnet <- function(mod.in,nid=T,all.out=T,all.in=T,bias=T,wts.only=F,rel.rsc=5,circle.cex=5,\n", "                    node.labs=T,var.labs=T,x.lab=NULL,y.lab=NULL,line.stag=NULL,struct=NULL,cex.val=1,\n", "                    alpha.val=1,circle.col='lightblue',pos.col='black',neg.col='grey', max.sp = F, ...){\n", "  \n", "  require(scales) \n", "  \n", "  #sanity checks\n", "  if('mlp' %in% class(mod.in)) warning('Bias layer not applicable for rsnns object')\n", "  if('numeric' %in% class(mod.in)){\n", "    if(is.null(struct)) stop('Three-element vector required for struct')\n", "    if(length(mod.in) != ((struct[1]*struct[2]+struct[2]*struct[3])+(struct[3]+struct[2])))\n", "      stop('Incorrect length of weight matrix for given network structure')\n", "  }\n", "  if('train' %in% class(mod.in)){\n", "    if('nnet' %in% class(mod.in$finalModel)){\n", "      mod.in<-mod.in$finalModel\n", "      warning('Using best nnet model from train output')\n", "    }\n", "    else stop('Only nnet method can be used with train object')\n", "  }\n", "  \n", "  #gets weights for neural network, output is list\n", "  #if rescaled argument is true, weights are returned but rescaled based on abs value\n", "  nnet.vals<-function(mod.in,nid,rel.rsc,struct.out=struct){\n", "    \n", "    require(scales)\n", "    require(reshape)\n", "    \n", "    if('numeric' %in% class(mod.in)){\n", "      struct.out<-struct\n", "      wts<-mod.in\n", "    }\n", "    \n", "    #neuralnet package\n", "    if('nn' %in% class(mod.in)){\n", "      struct.out<-unlist(lapply(mod.in$weights[[1]],ncol))\n", "    \tstruct.out<-struct.out[-length(struct.out)]\n", "    \tstruct.out<-c(\n", "    \t\tlength(mod.in$model.list$variables),\n", "    \t\tstruct.out,\n", "    \t\tlength(mod.in$model.list$response)\n", "    \t\t)    \t\t\n", "      wts<-unlist(mod.in$weights[[1]])   \n", "    }\n", "    \n", "    #nnet package\n", "    if('nnet' %in% class(mod.in)){\n", "      struct.out<-mod.in$n\n", "      wts<-mod.in$wts\n", "    }\n", "    \n", "    #RSNNS package\n", "    if('mlp' %in% class(mod.in)){\n", "      struct.out<-c(mod.in$nInputs,mod.in$archParams$size,mod.in$nOutputs)\n", "      hid.num<-length(struct.out)-2\n", "      wts<-mod.in$snnsObject$getCompleteWeightMatrix()\n", "      \n", "      #get all input-hidden and hidden-hidden wts\n", "      inps<-wts[grep('Input',row.names(wts)),grep('Hidden_2',colnames(wts)),drop=F]\n", "      inps<-melt(rbind(rep(NA,ncol(inps)),inps))$value\n", "      uni.hids<-paste0('Hidden_',1+seq(1,hid.num))\n", "      for(i in 1:length(uni.hids)){\n", "        if(is.na(uni.hids[i+1])) break\n", "        tmp<-wts[grep(uni.hids[i],rownames(wts)),grep(uni.hids[i+1],colnames(wts)),drop=F]\n", "        inps<-c(inps,melt(rbind(rep(NA,ncol(tmp)),tmp))$value)\n", "        }\n", "      \n", "      #get connections from last hidden to output layers\n", "      outs<-wts[grep(paste0('Hidden_',hid.num+1),row.names(wts)),grep('Output',colnames(wts)),drop=F]\n", "      outs<-rbind(rep(NA,ncol(outs)),outs)\n", "      \n", "      #weight vector for all\n", "      wts<-c(inps,melt(outs)$value)\n", "      assign('bias',F,envir=environment(nnet.vals))\n", "      }\n", "    \n", "    if(nid) wts<-rescale(abs(wts),c(1,rel.rsc))\n", "    \n", "    #convert wts to list with appropriate names \n", "    hid.struct<-struct.out[-c(length(struct.out))]\n", "    row.nms<-NULL\n", "    for(i in 1:length(hid.struct)){\n", "      if(is.na(hid.struct[i+1])) break\n", "      row.nms<-c(row.nms,rep(paste('hidden',i,seq(1:hid.struct[i+1])),each=1+hid.struct[i]))\n", "    }\n", "    row.nms<-c(\n", "      row.nms,\n", "      rep(paste('out',seq(1:struct.out[length(struct.out)])),each=1+struct.out[length(struct.out)-1])\n", "      )\n", "    out.ls<-data.frame(wts,row.nms)\n", "    out.ls$row.nms<-factor(row.nms,levels=unique(row.nms),labels=unique(row.nms))\n", "    out.ls<-split(out.ls$wts,f=out.ls$row.nms)\n", "    \n", "    assign('struct',struct.out,envir=environment(nnet.vals))\n", "    \n", "    out.ls\n", "    \n", "    }\n", "  \n", "  wts<-nnet.vals(mod.in,nid=F)\n", "  \n", "  if(wts.only) return(wts)\n", "  \n", "  #circle colors for input, if desired, must be two-vector list, first vector is for input layer\n", "  if(is.list(circle.col)){\n", "                    circle.col.inp<-circle.col[[1]]\n", "                    circle.col<-circle.col[[2]]\n", "                    }\n", "  else circle.col.inp<-circle.col\n", "  \n", "  #initiate plotting\n", "  x.range<-c(0,100)\n", "  y.range<-c(0,100)\n", "  #these are all proportions from 0-1\n", "  if(is.null(line.stag)) line.stag<-0.011*circle.cex/2\n", "  layer.x<-seq(0.17,0.9,length=length(struct))\n", "  bias.x<-layer.x[-length(layer.x)]+diff(layer.x)/2\n", "  bias.y<-0.95\n", "  circle.cex<-circle.cex\n", "  \n", "  #get variable names from mod.in object\n", "  #change to user input if supplied\n", "  if('numeric' %in% class(mod.in)){\n", "    x.names<-paste0(rep('X',struct[1]),seq(1:struct[1]))\n", "    y.names<-paste0(rep('Y',struct[3]),seq(1:struct[3]))\n", "  }\n", "  if('mlp' %in% class(mod.in)){\n", "    all.names<-mod.in$snnsObject$getUnitDefinitions()\n", "    x.names<-all.names[grep('Input',all.names$unitName),'unitName']\n", "    y.names<-all.names[grep('Output',all.names$unitName),'unitName']\n", "  }\n", "  if('nn' %in% class(mod.in)){\n", "    x.names<-mod.in$model.list$variables\n", "    y.names<-mod.in$model.list$respons\n", "  }\n", "  if('xNames' %in% names(mod.in)){\n", "    x.names<-mod.in$xNames\n", "    y.names<-attr(terms(mod.in),'factor')\n", "    y.names<-row.names(y.names)[!row.names(y.names) %in% x.names]\n", "  }\n", "  if(!'xNames' %in% names(mod.in) & 'nnet' %in% class(mod.in)){\n", "    if(is.null(mod.in$call$formula)){\n", "      x.names<-colnames(eval(mod.in$call$x))\n", "      y.names<-colnames(eval(mod.in$call$y))\n", "    }\n", "    else{\n", "      forms<-eval(mod.in$call$formula)\n", "      x.names<-mod.in$coefnames\n", "      facts<-attr(terms(mod.in),'factors')\n", "      y.check<-mod.in$fitted\n", "      if(ncol(y.check)>1) y.names<-colnames(y.check)\n", "      else y.names<-as.character(forms)[2]\n", "    } \n", "  }\n", "  #change variables names to user sub \n", "  if(!is.null(x.lab)){\n", "    if(length(x.names) != length(x.lab)) stop('x.lab length not equal to number of input variables')\n", "    else x.names<-x.lab\n", "  }\n", "  if(!is.null(y.lab)){\n", "    if(length(y.names) != length(y.lab)) stop('y.lab length not equal to number of output variables')\n", "    else y.names<-y.lab\n", "  }\n", "  \n", "  #initiate plot\n", "  plot(x.range,y.range,type='n',axes=F,ylab='',xlab='',...)\n", "  \n", "  #function for getting y locations for input, hidden, output layers\n", "  #input is integer value from 'struct'\n", "  get.ys<-function(lyr, max_space = max.sp){\n", "  \tif(max_space){ \n", "  \t\tspacing <- diff(c(0*diff(y.range),0.9*diff(y.range)))/lyr\n", "   \t} else {\n", "    \tspacing<-diff(c(0*diff(y.range),0.9*diff(y.range)))/max(struct)\n", "   \t}\n", "    \n", "  \t\tseq(0.5*(diff(y.range)+spacing*(lyr-1)),0.5*(diff(y.range)-spacing*(lyr-1)),\n", "        length=lyr)\n", "  }\n", "  \n", "  #function for plotting nodes\n", "  #'layer' specifies which layer, integer from 'struct'\n", "  #'x.loc' indicates x location for layer, integer from 'layer.x'\n", "  #'layer.name' is string indicating text to put in node\n", "  layer.points<-function(layer,x.loc,layer.name,cex=cex.val){\n", "    x<-rep(x.loc*diff(x.range),layer)\n", "    y<-get.ys(layer)\n", "    points(x,y,pch=21,cex=circle.cex,col=in.col,bg=bord.col)\n", "    if(node.labs) text(x,y,paste(layer.name,1:layer,sep=''),cex=cex.val)\n", "    if(layer.name=='I' & var.labs) text(x-line.stag*diff(x.range),y,x.names,pos=2,cex=cex.val)      \n", "    if(layer.name=='O' & var.labs) text(x+line.stag*diff(x.range),y,y.names,pos=4,cex=cex.val)\n", "  }\n", "  \n", "  #function for plotting bias points\n", "  #'bias.x' is vector of values for x locations\n", "  #'bias.y' is vector for y location\n", "  #'layer.name' is  string indicating text to put in node\n", "  bias.points<-function(bias.x,bias.y,layer.name,cex,...){\n", "    for(val in 1:length(bias.x)){\n", "      points(\n", "        diff(x.range)*bias.x[val],\n", "        bias.y*diff(y.range),\n", "        pch=21,col=in.col,bg=bord.col,cex=circle.cex\n", "      )\n", "      if(node.labs)\n", "        text(\n", "          diff(x.range)*bias.x[val],\n", "          bias.y*diff(y.range),\n", "          paste(layer.name,val,sep=''),\n", "          cex=cex.val\n", "        )\n", "    }\n", "  }\n", "  \n", "  #function creates lines colored by direction and width as proportion of magnitude\n", "  #use 'all.in' argument if you want to plot connection lines for only a single input node\n", "  layer.lines<-function(mod.in,h.layer,layer1=1,layer2=2,out.layer=F,nid,rel.rsc,all.in,pos.col,\n", "                        neg.col,...){\n", "    \n", "    x0<-rep(layer.x[layer1]*diff(x.range)+line.stag*diff(x.range),struct[layer1])\n", "    x1<-rep(layer.x[layer2]*diff(x.range)-line.stag*diff(x.range),struct[layer1])\n", "    \n", "    if(out.layer==T){\n", "      \n", "      y0<-get.ys(struct[layer1])\n", "      y1<-rep(get.ys(struct[layer2])[h.layer],struct[layer1])\n", "      src.str<-paste('out',h.layer)\n", "      \n", "      wts<-nnet.vals(mod.in,nid=F,rel.rsc)\n", "      wts<-wts[grep(src.str,names(wts))][[1]][-1]\n", "      wts.rs<-nnet.vals(mod.in,nid=T,rel.rsc)\n", "      wts.rs<-wts.rs[grep(src.str,names(wts.rs))][[1]][-1]\n", "      \n", "      cols<-rep(pos.col,struct[layer1])\n", "      cols[wts<0]<-neg.col\n", "      \n", "      if(nid) segments(x0,y0,x1,y1,col=cols,lwd=wts.rs)\n", "      else segments(x0,y0,x1,y1)\n", "      \n", "    }\n", "    \n", "    else{\n", "      \n", "      if(is.logical(all.in)) all.in<-h.layer\n", "      else all.in<-which(x.names==all.in)\n", "      \n", "      y0<-rep(get.ys(struct[layer1])[all.in],struct[2])\n", "      y1<-get.ys(struct[layer2])\n", "      src.str<-paste('hidden',layer1)\n", "      \n", "      wts<-nnet.vals(mod.in,nid=F,rel.rsc)\n", "      wts<-unlist(lapply(wts[grep(src.str,names(wts))],function(x) x[all.in+1]))\n", "      wts.rs<-nnet.vals(mod.in,nid=T,rel.rsc)\n", "      wts.rs<-unlist(lapply(wts.rs[grep(src.str,names(wts.rs))],function(x) x[all.in+1]))\n", "      \n", "      cols<-rep(pos.col,struct[layer2])\n", "      cols[wts<0]<-neg.col\n", "      \n", "      if(nid) segments(x0,y0,x1,y1,col=cols,lwd=wts.rs)\n", "      else segments(x0,y0,x1,y1)\n", "      \n", "    }\n", "    \n", "  }\n", "  \n", "  bias.lines<-function(bias.x,mod.in,nid,rel.rsc,all.out,pos.col,neg.col,...){\n", "    \n", "    if(is.logical(all.out)) all.out<-1:struct[length(struct)]\n", "    else all.out<-which(y.names==all.out)\n", "    \n", "    for(val in 1:length(bias.x)){\n", "      \n", "      wts<-nnet.vals(mod.in,nid=F,rel.rsc)\n", "      wts.rs<-nnet.vals(mod.in,nid=T,rel.rsc)\n", "      \n", "    \tif(val != length(bias.x)){\n", "        wts<-wts[grep('out',names(wts),invert=T)]\n", "        wts.rs<-wts.rs[grep('out',names(wts.rs),invert=T)]\n", "    \t\tsel.val<-grep(val,substr(names(wts.rs),8,8))\n", "    \t\twts<-wts[sel.val]\n", "    \t\twts.rs<-wts.rs[sel.val]\n", "    \t\t}\n", "    \n", "    \telse{\n", "        wts<-wts[grep('out',names(wts))]\n", "        wts.rs<-wts.rs[grep('out',names(wts.rs))]\n", "      \t}\n", "      \n", "      cols<-rep(pos.col,length(wts))\n", "      cols[unlist(lapply(wts,function(x) x[1]))<0]<-neg.col\n", "      wts.rs<-unlist(lapply(wts.rs,function(x) x[1]))\n", "      \n", "      if(nid==F){\n", "        wts.rs<-rep(1,struct[val+1])\n", "        cols<-rep('black',struct[val+1])\n", "      }\n", "      \n", "      if(val != length(bias.x)){\n", "        segments(\n", "          rep(diff(x.range)*bias.x[val]+diff(x.range)*line.stag,struct[val+1]),\n", "          rep(bias.y*diff(y.range),struct[val+1]),\n", "          rep(diff(x.range)*layer.x[val+1]-diff(x.range)*line.stag,struct[val+1]),\n", "          get.ys(struct[val+1]),\n", "          lwd=wts.rs,\n", "          col=cols\n", "        )\n", "      }\n", "      \n", "      else{\n", "        segments(\n", "          rep(diff(x.range)*bias.x[val]+diff(x.range)*line.stag,struct[val+1]),\n", "          rep(bias.y*diff(y.range),struct[val+1]),\n", "          rep(diff(x.range)*layer.x[val+1]-diff(x.range)*line.stag,struct[val+1]),\n", "          get.ys(struct[val+1])[all.out],\n", "          lwd=wts.rs[all.out],\n", "          col=cols[all.out]\n", "        )\n", "      }\n", "      \n", "    }\n", "  }\n", "  \n", "  #use functions to plot connections between layers\n", "  #bias lines\n", "  if(bias) bias.lines(bias.x,mod.in,nid=nid,rel.rsc=rel.rsc,all.out=all.out,pos.col=alpha(pos.col,alpha.val),\n", "                      neg.col=alpha(neg.col,alpha.val))\n", "  \n", "  #layer lines, makes use of arguments to plot all or for individual layers\n", "  #starts with input-hidden\n", "  #uses 'all.in' argument to plot connection lines for all input nodes or a single node\n", "  if(is.logical(all.in)){  \n", "    mapply(\n", "      function(x) layer.lines(mod.in,x,layer1=1,layer2=2,nid=nid,rel.rsc=rel.rsc,\n", "        all.in=all.in,pos.col=alpha(pos.col,alpha.val),neg.col=alpha(neg.col,alpha.val)),\n", "      1:struct[1]\n", "    )\n", "  }\n", "  else{\n", "    node.in<-which(x.names==all.in)\n", "    layer.lines(mod.in,node.in,layer1=1,layer2=2,nid=nid,rel.rsc=rel.rsc,all.in=all.in,\n", "                pos.col=alpha(pos.col,alpha.val),neg.col=alpha(neg.col,alpha.val))\n", "  }\n", "  #connections between hidden layers\n", "  lays<-split(c(1,rep(2:(length(struct)-1),each=2),length(struct)),\n", "              f=rep(1:(length(struct)-1),each=2))\n", "  lays<-lays[-c(1,(length(struct)-1))]\n", "  for(lay in lays){\n", "    for(node in 1:struct[lay[1]]){\n", "      layer.lines(mod.in,node,layer1=lay[1],layer2=lay[2],nid=nid,rel.rsc=rel.rsc,all.in=T,\n", "                  pos.col=alpha(pos.col,alpha.val),neg.col=alpha(neg.col,alpha.val))\n", "    }\n", "  }\n", "  #lines for hidden-output\n", "  #uses 'all.out' argument to plot connection lines for all output nodes or a single node\n", "  if(is.logical(all.out))\n", "    mapply(\n", "      function(x) layer.lines(mod.in,x,layer1=length(struct)-1,layer2=length(struct),out.layer=T,nid=nid,rel.rsc=rel.rsc,\n", "                              all.in=all.in,pos.col=alpha(pos.col,alpha.val),neg.col=alpha(neg.col,alpha.val)),\n", "      1:struct[length(struct)]\n", "      )\n", "  else{\n", "    node.in<-which(y.names==all.out)\n", "    layer.lines(mod.in,node.in,layer1=length(struct)-1,layer2=length(struct),out.layer=T,nid=nid,rel.rsc=rel.rsc,\n", "                pos.col=pos.col,neg.col=neg.col,all.out=all.out)\n", "  }\n", "  \n", "  #use functions to plot nodes\n", "  for(i in 1:length(struct)){\n", "    in.col<-bord.col<-circle.col\n", "    layer.name<-'H'\n", "    if(i==1) { layer.name<-'I'; in.col<-bord.col<-circle.col.inp}\n", "    if(i==length(struct)) layer.name<-'O'\n", "    layer.points(struct[i],layer.x[i],layer.name)\n", "    }\n", "\n", "  if(bias) bias.points(bias.x,bias.y,'B')\n", "  \n", "}"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "598bd7ede678d87f5b34a89edb9d68193e18827e", "_kg_hide-input": false, "_kg_hide-output": false, "_cell_guid": "1bd91c0f-2b0d-4743-9986-c3acf8d386ea"}}, {"execution_count": null, "source": ["library(devtools)\n", "library(reshape2)\n", "plot.nnet(final.age.ann)"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "f472e3c8968a42a457480f4de56a496f357eed0a", "_kg_hide-input": true, "_cell_guid": "e609ca33-2a17-4aca-9797-9aabdf417a2d"}}, {"source": ["**I used the plot.nnet function from the following link to lot the ANN model above.<br>\n", "[plot.nnet() reference](https://gist.githubusercontent.com/fawda123/7471137/raw/466c1474d0a505ff044412703516c34f1a4684a5/nnet_plot_update.r)**\n", "<br><br>Now let's take a look at its performance"], "cell_type": "markdown", "metadata": {"_uuid": "79cd3e3d0d2fd3f0c28ac3e2867209951f45068a", "_cell_guid": "107cb092-22c3-433c-923a-283818f26c84"}}, {"execution_count": null, "source": ["print(paste(\"sum_of_errors:\",sum(abs(final.age.ann.p - age.data.test$Age))))\n", "print(paste(\"average_errors:\",sum(abs(final.age.ann.p - age.data.test$Age))/178))"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "f96e08877888a9f33d70b94e77a3ae2c138c428c", "_kg_hide-input": true, "_cell_guid": "5fe95ba1-a818-4353-bb79-71dc794cc27d"}}, {"source": ["Well, that's slightly better than the linear regression model. I'd better use this model to fill in the NA values!"], "cell_type": "markdown", "metadata": {"_uuid": "00b0428925f99e337d42525ffe041464dc8f5597", "_cell_guid": "226da019-aeb3-4d7a-a9eb-15233cc9885e"}}, {"source": ["<a class='anchor' id='3.4'></a>\n", "## &nbsp;&nbsp;3.4 FILLING IN THE NAs IN AGE\n", "Now I'll fill in the NA values in the 'Age' variable in our original dataset!"], "cell_type": "markdown", "metadata": {"_uuid": "0128e16d22998b741098b0f961ab2fb69b967090", "_cell_guid": "72340348-5972-489e-8858-057b84447cbd"}}, {"execution_count": null, "source": ["NAindex <- which(is.na(data$Age))\n", "age.NA.data <- data[NAindex,]\n", "age.NA.solved <- predict(final.age.ann, newdata=age.NA.data)\n", "for (i in 1:177){\n", "  data$Age[NAindex[i]] <- age.NA.solved[i]\n", "}"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "fcf4a8093cd015f7f6957c59f944de2a0b8f48fc", "_cell_guid": "d2ba93cf-38e9-4263-96c4-cf66c5464a16"}}, {"source": ["Now we have our dataset without NAs!"], "cell_type": "markdown", "metadata": {"_uuid": "41a09e26faa90c7ea76343fa951d8b373318e414", "_cell_guid": "7c9f1b7d-5f04-48bf-8c21-36f3ff058ad9"}}, {"execution_count": null, "source": ["summary(data)"], "cell_type": "code", "outputs": [], "metadata": {"_uuid": "0a9caa9bb4e63cd17539c675669d17f375be05b2", "_cell_guid": "acef5198-0c49-4bc5-8224-ff2597552869"}}, {"source": ["[The link that will bring you back to where you came from..!](#0)"], "cell_type": "markdown", "metadata": {"_uuid": "de33c8c69aaab77d400943dfad7c2dad296dfd50", "_cell_guid": "8de6c81c-41df-425b-9aef-c5e17b8e256d"}}], "nbformat": 4}