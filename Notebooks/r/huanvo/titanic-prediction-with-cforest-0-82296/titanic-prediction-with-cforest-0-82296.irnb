{"cells":[{"metadata":{"_execution_state":"idle","_uuid":"c1c79f7d0ecadf2bfbd6d95f9d4f027ec43ededa","trusted":false,"_cell_guid":"033377e8-6f9c-4870-be2b-43aa389a67ed"},"cell_type":"markdown","source":"# Titanic Prediction with cforest to achieve 0.82296 (top 3%)\n\nI am a beginner in data science/machine learning. This is a straightforward model for the titanic data set using cforest that achieves an accuracy of 0.82296 (top 3%). The codes for this kernel are taken from \n\n[Titanic: Getting Started With R - Full Guide to 0.81340](https://www.kaggle.com/c/titanic/discussion/6821)\nby [Trevor Stephens](https://www.kaggle.com/trevorstephens).\n\n[Titanic: 2nd degree families and majority voting](https://www.kaggle.com/erikbruin/titanic-2nd-degree-families-and-majority-voting)\nby [Erik Bruin](https://www.kaggle.com/erikbruin)\n\nIf you find this kernel useful, please consider upvoting or sharing. Any suggestions to improve the model are welcome.  "},{"metadata":{"_uuid":"0715ca1877830e0a038c0238553c3e65a750fe88"},"cell_type":"markdown","source":"## Loading the R packages"},{"metadata":{"trusted":true,"_uuid":"c7dda83d42d379d0faa481ab5dc2fe8b0873f79d"},"cell_type":"code","source":"# Load packages\nlibrary('ggplot2') # visualization\nlibrary('ggthemes') # visualization\nlibrary('scales') # visualization\nlibrary('dplyr') # data manipulation\nlibrary('mice') # imputation\nlibrary('randomForest') # classification algorithm\nlibrary('rpart') #decision tree\nlibrary(party) #cforest ","execution_count":1,"outputs":[]},{"metadata":{"_uuid":"625f65270a4aa08b04b5ce139941c2e9cb88b615"},"cell_type":"markdown","source":"## Importing the data sets"},{"metadata":{"trusted":true,"_uuid":"cb6d075c030cea1fbf68bb8802df21e777c88adf"},"cell_type":"code","source":"train <- read.csv('../input/train.csv')\ntest  <- read.csv('../input/test.csv')","execution_count":2,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"05bd644f337c692bd1f96cb0b0c0ff65d2b3f1c6"},"cell_type":"code","source":"#checking the structure of the train set \nstr(train)","execution_count":3,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"85dfd47f37f72637bc0ce360733f1606623a39ba"},"cell_type":"code","source":"#checking the structure of the test set\nstr(test)","execution_count":5,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"ad3a9e513b8545b27f82e7751494a15616ed2257"},"cell_type":"code","source":"#load the first few rows of the data\nhead(train)","execution_count":6,"outputs":[]},{"metadata":{"_uuid":"cd0924d1ed71ec5b7be6a7980b523c54456f8a29"},"cell_type":"markdown","source":"## Feature Engineering"},{"metadata":{"_uuid":"1162a2653e2f1509ed3e39dac0f65f178cc8a8fc"},"cell_type":"markdown","source":"To do feature engineering we combine the two data sets "},{"metadata":{"trusted":true,"_uuid":"f5479195b765cbcf961e2cda72b3baad613737a5"},"cell_type":"code","source":"#create a Survived column for the test set filled with NAs\ntest$Survived <- NA\n\n#combine the train and test sets to a data set named combi\ncombi <- rbind(train, test)","execution_count":7,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"30f29900d2a4f1b1de3e3edca76e76beaee6b90b"},"cell_type":"code","source":"# summarize the combi data set\nsummary(combi)","execution_count":8,"outputs":[]},{"metadata":{"_uuid":"7b067db8def798fe89f3f648906cd5877128fe84"},"cell_type":"markdown","source":" ### Getting Title from Name"},{"metadata":{"_uuid":"c3e1dd5f836747c1e23b11db3ad377933a35b504"},"cell_type":"markdown","source":"As a first step we will extract the title from each name. Note that since Name is imported as a factor type, we first need to convert it to\na character type in order to apply the string operations"},{"metadata":{"trusted":true,"_uuid":"ce5e7db4ef13c13fced71025109d589039af4696"},"cell_type":"code","source":"# convert Name to character\ncombi$Name <- as.character(combi$Name)","execution_count":9,"outputs":[]},{"metadata":{"_uuid":"e3f2d2d04d1e919ec2c2eac7fbefacaf8433ce46"},"cell_type":"markdown","source":"Now to extract the title from each name, we create a new column called Title, where we use sapply to apply the function that will extract the title from each name. "},{"metadata":{"trusted":true,"_uuid":"d3bc1df5b4598cc2967a7fcb42a08088d734e7a9"},"cell_type":"code","source":"# extracting title from name\ncombi$Title <- sapply(combi$Name, FUN = function(x){strsplit(x, split = '[,.]')[[1]][2]})\n# removing white space from the title\ncombi$Title <- sub(' ','', combi$Title)","execution_count":11,"outputs":[]},{"metadata":{"_uuid":"e86755689fd04eab3faeeef076f748bd73ac1558"},"cell_type":"markdown","source":"Let us have a look at the distinct titles "},{"metadata":{"trusted":true,"_uuid":"72d648ebd3974d05396b2cee71bc54755eab693a"},"cell_type":"code","source":"table(combi$Title)","execution_count":12,"outputs":[]},{"metadata":{"_uuid":"af783a69adcd320472051666c5a4d8f2849e4a87"},"cell_type":"markdown","source":"Notice that some of the titles belong to the same category, so we put them together as follows. "},{"metadata":{"trusted":true,"_uuid":"9413f81b1f05e9ba4ff3bf551e7c4f4eaef7c5aa"},"cell_type":"code","source":"combi$Title[combi$Title %in% c('Mme', 'Mlle')] <- 'Mlle'\ncombi$Title[combi$Title %in% c('Capt', 'Don', 'Major', 'Sir', 'Jonkheer')] <- 'Sir'\ncombi$Title[combi$Title %in% c('Dona', 'Lady', 'the Countess')] <- 'Lady'","execution_count":13,"outputs":[]},{"metadata":{"_uuid":"4b0371927ecc048719614adec1e7e3a2c576b82b"},"cell_type":"markdown","source":"Finally we convert the type of Title to factor "},{"metadata":{"trusted":true,"_uuid":"85d8d822acf835b206dfb179bcf31dadfe592991"},"cell_type":"code","source":"combi$Title <- factor(combi$Title)","execution_count":14,"outputs":[]},{"metadata":{"_uuid":"c8160154be9f29200c619f31a358b65f5777f212"},"cell_type":"markdown","source":"### Creating a FamilyID feature"},{"metadata":{"_uuid":"07157882f49d13e15fb91f323882fd0817f0eb65"},"cell_type":"markdown","source":"Next we would like to create a FamilyID feature, which is the concatenation of Surname and number of family members. Then to we will group families with less than 3 family members as small families. \n\nFirst we create a FamilySize feature which is the total number of members in a family, including oneself. It is SibSp+Parch+1."},{"metadata":{"trusted":true,"_uuid":"9e608b9cce9cbc508763002996f458a3cd4bbf64"},"cell_type":"code","source":"combi$FamilySize <- combi$SibSp + combi$Parch + 1 ","execution_count":15,"outputs":[]},{"metadata":{"_uuid":"2c9d1f1c1bc2e55c087c43fc265076046e1bb195"},"cell_type":"markdown","source":"Then we create a Surname column which extracts the surname of each name"},{"metadata":{"trusted":true,"_uuid":"995d8b1db9d48d14a077e14b2cb90c3cf241f555"},"cell_type":"code","source":"combi$Surname <- sapply(combi$Name, FUN = function(x){strsplit(x, split = '[,.]')[[1]][1]})","execution_count":16,"outputs":[]},{"metadata":{"_uuid":"920d24e784a35234efa53cdd8296ef2131193a80"},"cell_type":"markdown","source":"Now we concatenate the FamilySize with Surname using the paste function. Note that we first need to convert FamilySize to character because we cannot concatenate features of different types."},{"metadata":{"trusted":true,"_uuid":"24ac59e70fc48ad5c98b1b456d3b6b7428573530"},"cell_type":"code","source":"combi$FamilyID <- paste(as.character(combi$FamilySize), combi$Surname, sep= \"\")","execution_count":17,"outputs":[]},{"metadata":{"_uuid":"8a806e73f53e8ae9facd205c61ee8b55d07cf3da"},"cell_type":"markdown","source":"Let us replace families with FamilySize <= 2 with small family"},{"metadata":{"trusted":true,"_uuid":"fee6ab4bf318126e1ea01030e100fa07b39b1053"},"cell_type":"code","source":"combi$FamilyID[combi$FamilySize <= 2] <- 'Small'","execution_count":18,"outputs":[]},{"metadata":{"_uuid":"386d50e8a93b219ff55025583bb1fd22c1f4b79b"},"cell_type":"markdown","source":"Let us look at our FamilyID feature"},{"metadata":{"trusted":true,"_uuid":"7056a7e8eb0261687d6ad6c1e04516c303da3bc5"},"cell_type":"code","source":"table(combi$FamilyID)","execution_count":19,"outputs":[]},{"metadata":{"_uuid":"d09b1df1a98094e2cb8ab7075afa2ccb8a02729a"},"cell_type":"markdown","source":"Observe that we still have some small families (<= 2 members) remaining, say 3Appleton. Let us clean the FamilyID feature a bit further. First we create a dataframe with distinct FamilyID"},{"metadata":{"trusted":true,"_uuid":"64c13dc1554bf6a4b73bd30b597a32110b331701"},"cell_type":"code","source":"famIDs <- data.frame(table(combi$FamilyID))","execution_count":20,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"ff038782da88ccd7426b6cde630f5bbe7b689ea9"},"cell_type":"code","source":"head(famIDs)","execution_count":21,"outputs":[]},{"metadata":{"_uuid":"e268157ff3a07efd083f74dd58c2789e36cac918"},"cell_type":"markdown","source":"Then we extract the families with <= 2 members"},{"metadata":{"trusted":true,"_uuid":"824c5b00af584bf291af32327345c19e78851df4"},"cell_type":"code","source":"famIDs <- famIDs[famIDs$Freq <= 2,]","execution_count":22,"outputs":[]},{"metadata":{"_uuid":"d863bd4e4c6199733aa351aa602ec461f8de9ede"},"cell_type":"markdown","source":"Then we label families with <=2 members as small families "},{"metadata":{"trusted":true,"_uuid":"f6d08b5b8d6bade0d69a3ccffd23f4a2c295eae2"},"cell_type":"code","source":"combi$FamilyID[combi$FamilyID %in% famIDs$Var1] <- 'Small'","execution_count":23,"outputs":[]},{"metadata":{"_uuid":"055085626e8cd1f7201972261c117a17c63eb3a3"},"cell_type":"markdown","source":"Finally we convert the FamilyID to factor "},{"metadata":{"trusted":true,"_uuid":"0e2bb883ae814d77644e2462421e7109451da35b"},"cell_type":"code","source":"combi$FamilyID <- factor(combi$FamilyID)","execution_count":24,"outputs":[]},{"metadata":{"_uuid":"4995e3b78a983ff03963a5bd8182f9b6798d214c"},"cell_type":"markdown","source":"Let us look at our FamilyID feature again"},{"metadata":{"trusted":true,"_uuid":"0ddc105cfd72dedc48784c792b73e381882ef49c"},"cell_type":"code","source":"table(combi$FamilyID)","execution_count":25,"outputs":[]},{"metadata":{"_uuid":"4c6f95f902d07de6a1503b243eab83dac6978fcd"},"cell_type":"markdown","source":"### Filling in missing Age values"},{"metadata":{"_uuid":"984af413bc8297617bec437783b8a1ab79685439"},"cell_type":"markdown","source":"Let's look at the Age feature"},{"metadata":{"trusted":true,"_uuid":"e8f0660db024a7cbbe2977e2099c546513ed9738"},"cell_type":"code","source":"summary(combi$Age)","execution_count":26,"outputs":[]},{"metadata":{"_uuid":"528e879a9c3ff424c7a77f90ddc6d0f54c0210ed"},"cell_type":"markdown","source":"To fill in 263 missing values we use Decision Tree to to predicting the Age value"},{"metadata":{"trusted":true,"_uuid":"5cdc88537bbe4f14e2a6051956dc60fc6b9eb312"},"cell_type":"code","source":"Agefit <- rpart(Age ~ Pclass + Sex + SibSp + Parch + Fare + Embarked + Title + FamilySize,\n               data = combi[!is.na(combi$Age),],\n               method = \"anova\")\ncombi$Age[is.na(combi$Age)] <- predict(Agefit, combi[is.na(combi$Age),])","execution_count":27,"outputs":[]},{"metadata":{"_uuid":"c9823c1b9050de5f374c851d5574ac0132d43cbd"},"cell_type":"markdown","source":"### Filling in the missing Embarked values"},{"metadata":{"_uuid":"2c2dbc84c519f002e8d56188343ef978b5dc5e31"},"cell_type":"markdown","source":"Let us look at the Embarked feature"},{"metadata":{"trusted":true,"_uuid":"bad96d4302de16f167a4b7c34c5b8249c4e9bbb0"},"cell_type":"code","source":"table(combi$Embarked)","execution_count":28,"outputs":[]},{"metadata":{"_uuid":"f35e62da120be3d2080d9e65f74c6893ff701705"},"cell_type":"markdown","source":"Observe that we have two Embarked values which are blank (missing). We will fill those with the most popular Embarked value, namely 'S'."},{"metadata":{"trusted":true,"_uuid":"182656a2c4a0b3d39d15352f7590fc64ac0db6f0"},"cell_type":"code","source":"# find the position of the missing value\nwhich(combi$Embarked == '')","execution_count":29,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"ead3ad35500910eba9cd74496a8f7373b3c0227f"},"cell_type":"code","source":"# fill in those positions with 'S'\ncombi$Embarked[c(62, 830)] = \"S\"\n\n#convert Embarked to factor\ncombi$Embarked <- factor(combi$Embarked)","execution_count":30,"outputs":[]},{"metadata":{"_uuid":"dd9c0292b2a3f2342d3edb8d874cce200eae5db4"},"cell_type":"markdown","source":"## Filling in the missing Fare values"},{"metadata":{"_uuid":"d72ffddd63ec10e61329bd082385fecee4a0a7da"},"cell_type":"markdown","source":"We will fill the missing Fare values by the median of the fare"},{"metadata":{"trusted":true,"_uuid":"647ad71d110ecce0203f5a1ba175ef8a538c258d"},"cell_type":"code","source":"# find the position of the missing Fare value\nwhich(is.na(combi$Fare))","execution_count":32,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"59750263a2a48de76abd02912903bb1d1d7c1ba1"},"cell_type":"code","source":"# fill in the missing value with the media\ncombi$Fare[1044] <- median(combi$Fare, na.rm = TRUE)","execution_count":33,"outputs":[]},{"metadata":{"_uuid":"9a0b7629754a190d5c9d509cc09c87c6c74fedd3"},"cell_type":"markdown","source":"### Creating the FarePP feature"},{"metadata":{"_uuid":"5e5b2687287c3453ac661009ae37e3e36db0583e"},"cell_type":"markdown","source":"Now we would like to create the FarePP feature, namely fare per person. To achieve this we will find the number of people which share the same ticket, then divide the total tikect fare by the number of people. Finally we replace the people whose ticket fares = 0 with the mean of the ticket fare based on Pclass. \n\nFirst we create a Tsize feature which indicates the number of people with the same ticket. "},{"metadata":{"trusted":true,"_uuid":"32c49f35b9a9c61beed83c478d30ff71426ef14b"},"cell_type":"code","source":"# create a dataframe TicketGroup that group by the ticket\nTicketGroup <- combi %>%\n            select(Ticket) %>%\n            group_by(Ticket) %>%\n            summarise(Tsize=n())\n\n#join the TicketGroup dataframe to combi on the Ticket feature\ncombi <- left_join(combi, TicketGroup, by = \"Ticket\")","execution_count":34,"outputs":[]},{"metadata":{"_uuid":"9feef537c54cc43df2dccf5eb52bea634e7ade26"},"cell_type":"markdown","source":"Then the FarePP feature is obtained by Fare/Tsize"},{"metadata":{"trusted":true,"_uuid":"dca037c9f876a4055a0c2d347e5889b75018b0f1"},"cell_type":"code","source":"#creating the fare per person variable \ncombi$FarePP <- combi$Fare/combi$Tsize","execution_count":35,"outputs":[]},{"metadata":{"_uuid":"ae57bae79c6e62ec8a175f3e0ae44bc90625a2ab"},"cell_type":"markdown","source":"Finally we replace the FarePP = 0 by the mean Fare based on Pclass"},{"metadata":{"trusted":true,"_uuid":"eb8ec7877b18115c7c4f87d5e646161c2ed7d789"},"cell_type":"code","source":"#create a dataframe tab3 which computes the mean fare based on Pclass\ntab3 <- combi[(!is.na(combi$FarePP)),] %>%\n        group_by(Pclass) %>%\n        summarise(MeanFarePP = mean(FarePP))\n# join the dataframe tab3 to combi on the Pclass feature\ncombi <- left_join(combi, tab3, by =\"Pclass\")\n# replace FarePP = 0 by the mean fare based on Pclass\ncombi$FarePP[which(combi$FarePP==0)] <- combi$MeanFarePP[which(combi$FarePP==0)]","execution_count":36,"outputs":[]},{"metadata":{"_uuid":"569ba531e653ae2f6a739ae38cd6234ba172ba98"},"cell_type":"markdown","source":"## Modelling"},{"metadata":{"_uuid":"88d5f18d77b833600ddb9c2181916c14ef0b6f93"},"cell_type":"markdown","source":"Now we are ready to fit our data into the model. Here we will use cforest, which is an enhanced version of random forest. But first we need to split our combi dataset into the original train and test set "},{"metadata":{"trusted":true,"_uuid":"a2d25ffa9a2464bfa7ee4bf3380bbf39a997372c"},"cell_type":"code","source":"train <- combi[1:891,]\ntest <- combi[892:1309,]","execution_count":37,"outputs":[]},{"metadata":{"_uuid":"18ce94b23055b3023112712458dcc70fd226944b"},"cell_type":"markdown","source":"Now we fit the train data into the cforest model. Note that this will take a while, so be patient :)"},{"metadata":{"trusted":true,"_uuid":"568f6058a081c6eb6555c6471bad1581716ccfd8"},"cell_type":"code","source":"set.seed(415)\nfit <- cforest(as.factor(Survived) ~ Pclass + Sex + Age + SibSp + Parch + FarePP +\n                                       Embarked + Title + FamilySize + FamilyID,\n                 data = train, \n                 controls=cforest_unbiased(ntree=2000, mtry=3))","execution_count":38,"outputs":[]},{"metadata":{"_uuid":"da18b81ae9acfe453f3a594123d1a05f22042b1d"},"cell_type":"markdown","source":"Then we predict the test set"},{"metadata":{"trusted":true,"_uuid":"108412ef4cb08cbe33627096fdb410de471da195"},"cell_type":"code","source":"Prediction <- predict(fit, test, OOB=TRUE, type = \"response\")","execution_count":39,"outputs":[]},{"metadata":{"_uuid":"7a3d010fae78c6c930a760d8fbf84c171f05db2e"},"cell_type":"markdown","source":"Finally we prepare the submission"},{"metadata":{"trusted":true,"_uuid":"1721817d7bdbd5552b3b17207d4970bf5eb306a7"},"cell_type":"code","source":"submit <- data.frame(PassengerId = test$PassengerId, Survived = Prediction)\nwrite.csv(submit, file = \"TitanicPredictionRFare\", row.names = FALSE)","execution_count":40,"outputs":[]},{"metadata":{"_uuid":"1a39c21678b4938cefccf82d43e2584839269e52"},"cell_type":"markdown","source":"That's it. It should give you an accuracy score of 0.82296 (top 3%). I hope this kernel is useful for you. Let me know your thoughts and suggestions below :)."},{"metadata":{"trusted":true,"_uuid":"e6fda2598ba8586cfbed8bc47e5b8a88d9ed6bf1"},"cell_type":"code","source":"","execution_count":null,"outputs":[]}],"metadata":{"kernelspec":{"display_name":"R","language":"R","name":"ir"},"language_info":{"mimetype":"text/x-r-source","name":"R","pygments_lexer":"r","version":"3.4.2","file_extension":".r","codemirror_mode":"r"}},"nbformat":4,"nbformat_minor":1}