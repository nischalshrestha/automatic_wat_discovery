import time
import multiprocessing
import pickle
import pandas as pd
import numpy as np
import rpy2
import rpy2.robjects as robjects
from rpy2.robjects import pandas2ri
pandas2ri.activate()

import sys
sys.path.append("../")
from generate import generate_args, generate_simple_arg

NUM_WORKERS = 4
PICKLE_PATH = '/Volumes/TarDisk/snippets/'
RSNIPS_PATH = "rsnips.csv"

flatten = lambda l: [item for sublist in l for item in sublist]

generated_args = generate_args(1, lang="r")
# TODO iteratively improve performance, testing a small amount of arg first
# generated_args = generate_simple_arg(lang="r")

class DataframeStore:
    """Just a class to store a dict of <snippet, output> so it can be pickled"""
    pairs = {}
    def __init__(self, pairs):
        self.pairs = pairs
    def get_output(self):
       return self.pairs
    
def eval_expr(df, expr):
    """
    Evals an R expression given a dataframe.
    Currently, this does not factor in args for expr
    """
    try:
        # Introduce df as mslacc into global env
        robjects.globalenv['mslacc'] = df
        # Rpy2 when evaluating using 'r', returns _something_ no matter what
        # even if expr is just an assignment
        output = robjects.r(f"""{expr}""")
        # If the output is a NULL it means expression doesn't return anything.
        # For e.g. when setting a column to NULL and deleting it
        # In such a case, simply return the original dataframe as the output
        # Note: need to be careful in analysis since it doesn't mean the expr
        # actually produced a dataframe; a solution is to add another meta data
        # indicating that the expr had returned a NULL.
        if type(output) == rpy2.rinterface.NULLType:
            output = robjects.globalenv['mslacc']
        # print(expr, type(output))
        robjects.r("rm(list = ls())")
        return expr, output
    except Exception as e:
        # print(e)
        return e
    
def execute_statement(snip):
    test_results = []
    for i, arg in enumerate(generated_args):
        result = eval_expr(arg, snip)
        if type(result) == tuple:
            if type(result[1]) == pd.DataFrame:
                test_results.append(result[1])
            else:
                return None
        else:
            # err = str(result)
            # test_results.append("ERROR: "+err)
            return None
    rtn = {'expr': snip, 'test_results': test_results}
    return rtn
    
def execute_statements():
    """Execute R snippets with random dataframes"""
    # Read python snippets generated by filer.py
    snips = pd.read_csv(RSNIPS_PATH)
    snippets = flatten(snips.values)
    # Eval expressions and collect successful ones paired with output: (expr, output)
    start_time = time.time()
    with multiprocessing.Pool(processes=NUM_WORKERS) as pool:
        results = pool.map_async(execute_statement, snippets, chunksize=len(snippets)//4)
        results.wait()
        result = results.get()
    end_time = time.time()
    filtered = list(filter(None, result))
    print(f"Total snips: {len(filtered)}")
    print(f"Time taken: {round((end_time - start_time), 2)} secs")
    return filtered

def print_full(x):
    try:
        pd.set_option('display.max_rows', len(x))
        print(x)
        pd.reset_option('display.max_rows')
    except:
        pass

if __name__ == '__main__':
    executions = execute_statements()
    df_store = DataframeStore(executions)
    pickle.dump(df_store, open(PICKLE_PATH+"r_dfs.pkl", "wb"))

